\chapter{樹}

LeetCode 上二叉樹的節點定義如下：
\begin{Code}
// 樹的節點
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(nullptr), right(nullptr) { }
};
\end{Code}


\section{二叉樹的遍歷} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

樹的遍歷有兩類：深度優先遍歷和寬度優先遍歷。深度優先遍歷又可分為兩種：先根（次序）遍歷和後根（次序）遍歷。

樹的先根遍歷是：先訪問樹的根結點，然後依次先根遍歷根的各棵子樹。樹的先跟遍歷的結果與對應二叉樹（孩子兄弟表示法）的先序遍歷的結果相同。

樹的後根遍歷是：先依次後根遍歷樹根的各棵子樹，然後訪問根結點。樹的後跟遍歷的結果與對應二叉樹的中序遍歷的結果相同。

二叉樹的先根遍歷有：\textbf{先序遍歷}(root->left->right)，root->right->left；後根遍歷有：\textbf{後序遍歷}(left->right->root)，right->left->root；二叉樹還有個一般的樹沒有的遍歷次序，\textbf{中序遍歷}(left->root->right)。


\subsection{Binary Tree Preorder Traversal}
\label{sec:binary-tree-preorder-traversal}


\subsubsection{描述}
Given a binary tree, return the \emph{preorder} traversal of its nodes' values.

For example:
Given binary tree \code{\{1,\#,2,3\}},
\begin{Code}
 1
  \
   2
  /
 3
\end{Code}
return \code{\[1,2,3\]}.

Note: Recursive solution is trivial, could you do it iteratively?


\subsubsection{分析}
用棧或者Morris遍歷。


\subsubsection{棧}
\begin{Code}
// LeetCode, Binary Tree Preorder Traversal
// 使用棧，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> result;
        stack<const TreeNode *> s;
        if (root != nullptr) s.push(root);

        while (!s.empty()) {
            const TreeNode *p = s.top();
            s.pop();
            result.push_back(p->val);

            if (p->right != nullptr) s.push(p->right);
            if (p->left != nullptr) s.push(p->left);
        }
        return result;
    }
};
\end{Code}


\subsubsection{Morris先序遍歷}
\begin{Code}
// LeetCode, Binary Tree Preorder Traversal
// Morris先序遍歷，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    vector<int> preorderTraversal(TreeNode *root) {
        vector<int> result;
        TreeNode *cur = root, *prev = nullptr;

        while (cur != nullptr) {
            if (cur->left == nullptr) {
                result.push_back(cur->val);
                prev = cur; /* cur剛剛被訪問過 */
                cur = cur->right;
            } else {
                /* 查找前驅 */
                TreeNode *node = cur->left;
                while (node->right != nullptr && node->right != cur)
                    node = node->right;

                if (node->right == nullptr) { /* 還沒線索化，則建立線索 */
                    result.push_back(cur->val); /* 僅這一行的位置與中序不同 */
                    node->right = cur;
                    prev = cur; /* cur剛剛被訪問過 */
                    cur = cur->left;
                } else {    /* 已經線索化，則刪除線索  */
                    node->right = nullptr;
                    /* prev = cur; 不能有這句，cur已經被訪問 */
                    cur = cur->right;
                }
            }
        }
        return result;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Inorder Traversal，見 \S \ref{sec:binary-tree-inorder-traversal}
\item Binary Tree Postorder Traversal，見 \S \ref{sec:binary-tree-postorder-traversal}
\item Recover Binary Search Tree，見 \S \ref{sec:recover-binary-search-tree}
\myenddot


\subsection{Binary Tree Inorder Traversal}
\label{sec:binary-tree-inorder-traversal}


\subsubsection{描述}
Given a binary tree, return the \emph{inorder} traversal of its nodes' values.

For example:
Given binary tree \code{\{1,\#,2,3\}},
\begin{Code}
 1
  \
   2
  /
 3
\end{Code}
return \code{\[1,3,2\]}.

Note: Recursive solution is trivial, could you do it iteratively?


\subsubsection{分析}
用棧或者Morris遍歷。


\subsubsection{棧}
\begin{Code}
// LeetCode, Binary Tree Inorder Traversal
// 使用棧，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> result;
        stack<const TreeNode *> s;
        const TreeNode *p = root;

        while (!s.empty() || p != nullptr) {
            if (p != nullptr) {
                s.push(p);
                p = p->left;
            } else {
                p = s.top();
                s.pop();
                result.push_back(p->val);
                p = p->right;
            }
        }
        return result;
    }
};
\end{Code}


\subsubsection{Morris中序遍歷}
\begin{Code}
// LeetCode, Binary Tree Inorder Traversal
// Morris中序遍歷，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    vector<int> inorderTraversal(TreeNode *root) {
        vector<int> result;
        TreeNode *cur = root, *prev = nullptr;

        while (cur != nullptr) {
            if (cur->left == nullptr) {
                result.push_back(cur->val);
                prev = cur;
                cur = cur->right;
            } else {
                /* 查找前驅 */
                TreeNode *node = cur->left;
                while (node->right != nullptr && node->right != cur)
                    node = node->right;

                if (node->right == nullptr) { /* 還沒線索化，則建立線索 */
                    node->right = cur;
                    /* prev = cur; 不能有這句，cur還沒有被訪問 */
                    cur = cur->left;
                } else {    /* 已經線索化，則訪問節點，並刪除線索  */
                    result.push_back(cur->val);
                    node->right = nullptr;
                    prev = cur;
                    cur = cur->right;
                }
            }
        }
        return result;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Preorder Traversal，見 \S \ref{sec:binary-tree-preorder-traversal}
\item Binary Tree Postorder Traversal，見 \S \ref{sec:binary-tree-postorder-traversal}
\item Recover Binary Search Tree，見 \S \ref{sec:recover-binary-search-tree}
\myenddot


\subsection{Binary Tree Postorder Traversal}
\label{sec:binary-tree-postorder-traversal}


\subsubsection{描述}
Given a binary tree, return the \emph{postorder} traversal of its nodes' values.

For example:
Given binary tree \code{\{1,\#,2,3\}},
\begin{Code}
 1
  \
   2
  /
 3
\end{Code}
return \code{\[3,2,1\]}.

Note: Recursive solution is trivial, could you do it iteratively?


\subsubsection{分析}
用棧或者Morris遍歷。


\subsubsection{棧}
\begin{Code}
// LeetCode, Binary Tree Postorder Traversal
// 使用棧，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> result;
        stack<const TreeNode *> s;
        /* p，正在訪問的結點，q，剛剛訪問過的結點*/
        const TreeNode *p = root, *q = nullptr;

        do {
            while (p != nullptr) { /* 往左下走*/
                s.push(p);
                p = p->left;
            }
            q = nullptr;
            while (!s.empty()) {
                p = s.top();
                s.pop();
                /* 右孩子不存在或已被訪問，訪問之*/
                if (p->right == q) {
                    result.push_back(p->val);
                    q = p; /* 保存剛訪問過的結點*/
                } else {
                    /* 當前結點不能訪問，需第二次進棧*/
                    s.push(p);
                    /* 先處理右子樹*/
                    p = p->right;
                    break;
                }
            }
        } while (!s.empty());

        return result;
    }
};
\end{Code}


\subsubsection{Morris後序遍歷}
\begin{Code}
// LeetCode, Binary Tree Postorder Traversal
// Morris後序遍歷，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    vector<int> postorderTraversal(TreeNode *root) {
        vector<int> result;
        TreeNode dummy(-1);
        TreeNode *cur, *prev = nullptr;
        std::function < void(const TreeNode*)> visit = 
            [&result](const TreeNode *node){
            result.push_back(node->val); 
        };

        dummy.left = root;
        cur = &dummy;
        while (cur != nullptr) {
            if (cur->left == nullptr) {
                prev = cur; /* 必須要有 */
                cur = cur->right;
            } else {
                TreeNode *node = cur->left;
                while (node->right != nullptr && node->right != cur)
                    node = node->right;

                if (node->right == nullptr) { /* 還沒線索化，則建立線索 */
                    node->right = cur;
                    prev = cur; /* 必須要有 */
                    cur = cur->left;
                } else { /* 已經線索化，則訪問節點，並刪除線索  */
                    visit_reverse(cur->left, prev, visit);
                    prev->right = nullptr;
                    prev = cur; /* 必須要有 */
                    cur = cur->right;
                }
            }
        }
        return result;
    }
private:
    // 逆轉路徑
    static void reverse(TreeNode *from, TreeNode *to) {
        TreeNode *x = from, *y = from->right, *z;
        if (from == to) return;

        while (x != to) {
            z = y->right;
            y->right = x;
            x = y;
            y = z;
        }
    }

    // 訪問逆轉後的路徑上的所有結點
    static void visit_reverse(TreeNode* from, TreeNode *to, 
                     std::function< void(const TreeNode*) >& visit) {
        TreeNode *p = to;
        reverse(from, to);

        while (true) {
            visit(p);
            if (p == from)
                break;
            p = p->right;
        }

        reverse(to, from);
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Preorder Traversal，見 \S \ref{sec:binary-tree-preorder-traversal}
\item Binary Tree Inorder Traversal，見 \S \ref{sec:binary-tree-inorder-traversal}
\item Recover Binary Search Tree，見 \S \ref{sec:recover-binary-search-tree}
\myenddot


\subsection{Binary Tree Level Order Traversal}
\label{sec:binary-tree-level-order-traversal}


\subsubsection{描述}
Given a binary tree, return the level order traversal of its nodes' values. (ie, from left to right, level by level).

For example:
Given binary tree \code{\{3,9,20,\#,\#,15,7\}},
\begin{Code}
    3
   / \
  9  20
    /  \
   15   7
\end{Code}
return its level order traversal as:
\begin{Code}
[
  [3],
  [9,20],
  [15,7]
]
\end{Code}


\subsubsection{分析}
無


\subsubsection{遞歸版}
\begin{Code}
// LeetCode, Binary Tree Level Order Traversal
// 遞歸版，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int>> result;
        traverse(root, 1, result);
        return result;
    }

    void traverse(TreeNode *root, size_t level, vector<vector<int>> &result) {
        if (!root) return;

        if (level > result.size())
            result.push_back(vector<int>());

        result[level-1].push_back(root->val);
        traverse(root->left, level+1, result);
        traverse(root->right, level+1, result);
    }
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
// LeetCode, Binary Tree Level Order Traversal
// 迭代版，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    vector<vector<int> > levelOrder(TreeNode *root) {
        vector<vector<int> > result;
        queue<TreeNode*> current, next;
        
        if(root == nullptr) {
            return result;
        } else {
            current.push(root);
        }

        while (!current.empty()) {
            vector<int> level; // elments in one level
            while (!current.empty()) {
                TreeNode* node = current.front();
                current.pop();
                level.push_back(node->val);
                if (node->left != nullptr) next.push(node->left);
                if (node->right != nullptr) next.push(node->right);
            }
            result.push_back(level);
            swap(next, current);
        }
        return result;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Level Order Traversal II，見 \S \ref{sec:binary-tree-level-order-traversal-ii}
\item Binary Tree Zigzag Level Order Traversal，見 \S \ref{sec:binary-tree-zigzag-level-order-traversal}
\myenddot


\subsection{Binary Tree Level Order Traversal II}
\label{sec:binary-tree-level-order-traversal-ii}


\subsubsection{描述}
Given a binary tree, return the bottom-up level order traversal of its nodes' values. (ie, from left to right, level by level from leaf to root).

For example:
Given binary tree \code{\{3,9,20,\#,\#,15,7\}},
\begin{Code}
    3
   / \
  9  20
    /  \
   15   7
\end{Code}
return its bottom-up level order traversal as:
\begin{Code}
[
  [15,7]
  [9,20],
  [3],
]
\end{Code}


\subsubsection{分析}
在上一題（見\S \ref{sec:binary-tree-level-order-traversal}）的基礎上，\fn{reverse()}一下即可。


\subsubsection{遞歸版}
\begin{Code}
// LeetCode, Binary Tree Level Order Traversal II
// 遞歸版，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int>> result;
        traverse(root, 1, result);
        std::reverse(result.begin(), result.end()); // 比上一題多此一行
        return result;
    }

    void traverse(TreeNode *root, size_t level, vector<vector<int>> &result) {
        if (!root) return;

        if (level > result.size())
            result.push_back(vector<int>());

        result[level-1].push_back(root->val);
        traverse(root->left, level+1, result);
        traverse(root->right, level+1, result);
    }
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
// LeetCode, Binary Tree Level Order Traversal II
// 迭代版，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    vector<vector<int> > levelOrderBottom(TreeNode *root) {
        vector<vector<int> > result;
        if(root == nullptr) return result;

        queue<TreeNode*> current, next;
        vector<int> level; // elments in level level

        current.push(root);
        while (!current.empty()) {
            while (!current.empty()) {
                TreeNode* node = current.front();
                current.pop();
                level.push_back(node->val);
                if (node->left != nullptr) next.push(node->left);
                if (node->right != nullptr) next.push(node->right);
            }
            result.push_back(level);
            level.clear();
            swap(next, current);
        }
        reverse(result.begin(), result.end()); // 比上一題多此一行
        return result;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Level Order Traversal，見 \S \ref{sec:binary-tree-level-order-traversal}
\item Binary Tree Zigzag Level Order Traversal，見 \S \ref{sec:binary-tree-zigzag-level-order-traversal}
\myenddot


\subsection{Binary Tree Zigzag Level Order Traversal}
\label{sec:binary-tree-zigzag-level-order-traversal}


\subsubsection{描述}
Given a binary tree, return the zigzag level order traversal of its nodes' values. (ie, from left to right, then right to left for the next level and alternate between).

For example:
Given binary tree \code{{3,9,20,\#,\#,15,7}},
\begin{Code}
    3
   / \
  9  20
    /  \
   15   7
\end{Code}
return its zigzag level order traversal as:
\begin{Code}
[
  [3],
  [20,9],
  [15,7]
]
\end{Code}


\subsubsection{分析}
廣度優先遍歷，用一個bool記錄是從左到右還是從右到左，每一層結束就翻轉一下。


\subsubsection{遞歸版}
\begin{Code}
// LeetCode, Binary Tree Zigzag Level Order Traversal
// 遞歸版，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
        vector<vector<int>> result;
        traverse(root, 1, result, true);
        return result;
    }

    void traverse(TreeNode *root, size_t level, vector<vector<int>> &result,
            bool left_to_right) {
        if (!root) return;

        if (level > result.size())
            result.push_back(vector<int>());

        if (left_to_right)
            result[level-1].push_back(root->val);
        else
            result[level-1].insert(result[level-1].begin(), root->val);

        traverse(root->left, level+1, result, !left_to_right);
        traverse(root->right, level+1, result, !left_to_right);
    }
};
\end{Code}

\subsubsection{迭代版}
\begin{Code}
// LeetCode, Binary Tree Zigzag Level Order Traversal
// 廣度優先遍歷，用一個bool記錄是從左到右還是從右到左，每一層結束就翻轉一下。
// 迭代版，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<vector<int> > zigzagLevelOrder(TreeNode *root) {
        vector<vector<int> > result;
        queue<TreeNode*> current, next;
        bool left_to_right = true;
        
        if(root == nullptr) {
            return result;
        } else {
            current.push(root);
        }

        while (!current.empty()) {
            vector<int> level; // elments in one level
            while (!current.empty()) {
                TreeNode* node = current.front();
                current.pop();
                level.push_back(node->val);
                if (node->left != nullptr) next.push(node->left);
                if (node->right != nullptr) next.push(node->right);
            }
            if (!left_to_right) reverse(level.begin(), level.end());
            result.push_back(level);
            left_to_right = !left_to_right;
            swap(next, current);
        }
        return result;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Level Order Traversal，見 \S \ref{sec:binary-tree-level-order-traversal}
\item Binary Tree Level Order Traversal II，見 \S \ref{sec:binary-tree-level-order-traversal-ii}
\myenddot

\subsection{Binary Tree Right side View}
\label{sec:binary-tree-right-side-view}


\subsubsection{描述}
Given a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.

For example:
Given binary tree \code{{3,9,20,\#,\#,15,7}},
\begin{Code}
    3     <--
   / \
  9  20   <--
    /  \
   15   7 <--
\end{Code}
return as:
\begin{Code}
[3,20,7]
\end{Code}


\subsubsection{分析}
雙 queue BFS zigzag travel, 只選最右

\subsubsection{遞歸版}
\begin{Code}
// LeetCode, Binary Tree Zigzag Level Order Traversal
// 遞歸版，時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<int> rightSideView(TreeNode* root) {
        if (root == nullptr) return vector<int>();
        vector<int> result;
        
        // 雙 queue BFS zigzag travel
        queue<TreeNode*> cur, next;
        cur.push(root);
        while (!cur.empty())
        {
            while (!cur.empty())
            {
                TreeNode *p = cur.front();
                cur.pop();
                
                if (cur.size() == 0) // 只選最右
                    result.push_back(p->val);
                
                if (p->left) next.push(p->left);
                if (p->right) next.push(p->right);
            }
            swap(cur, next);
        }
        
        return result;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Level Order Traversal，見 \S \ref{sec:binary-tree-level-order-traversal}
\item Binary Tree Level Order Traversal II，見 \S \ref{sec:binary-tree-level-order-traversal-ii}
\myenddot

\subsection{Recover Binary Search Tree}
\label{sec:recover-binary-search-tree}


\subsubsection{描述}
Two elements of a binary search tree (BST) are swapped by mistake.

Recover the tree without changing its structure.

Note: A solution using $O(n)$ space is pretty straight forward. Could you devise a constant space solution?


\subsubsection{分析}
$O(n)$空間的解法是，開一個指針數組，中序遍歷，將節點指針依次存放到數組裏，然後尋找兩處逆向的位置，先從前往後找第一個逆序的位置，然後從後往前找第二個逆序的位置，交換這兩個指針的值。

中序遍歷一般需要用到棧，空間也是$O(n)$的，如何才能不使用棧？Morris中序遍歷。


\subsubsection{代碼}

\begin{Code}
// LeetCode, Recover Binary Search Tree
// Morris中序遍歷，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    void recoverTree(TreeNode* root) {
        pair<TreeNode*, TreeNode*> broken;
        TreeNode* prev = nullptr;
        TreeNode* cur = root;

        while (cur != nullptr) {
            if (cur->left == nullptr) {
                detect(broken, prev, cur);
                prev = cur;
                cur = cur->right;
            } else {
                auto node = cur->left;

                while (node->right != nullptr && node->right != cur)
                    node = node->right;

                if (node->right == nullptr) {
                    node->right = cur;
                    //prev = cur; 不能有這句！因為cur還沒有被訪問
                    cur = cur->left;
                } else {
                    detect(broken, prev, cur);
                    node->right = nullptr;
                    prev = cur;
                    cur = cur->right;
                }
            }
        }

        swap(broken.first->val, broken.second->val);
    }

    void detect(pair<TreeNode*, TreeNode*>& broken, TreeNode* prev,
            TreeNode* current) {
        if (prev != nullptr && prev->val > current->val) {
            if (broken.first == nullptr) {
                broken.first = prev;
            } //不能用else，例如 {0,1}，會導致最後 swap時second為nullptr，
              //會 Runtime Error
            broken.second = current;
        }
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Binary Tree Inorder Traversal，見 \S \ref{sec:binary-tree-inorder-traversal}
\myenddot


\subsection{Same Tree}
\label{sec:same-tree}


\subsubsection{描述}
Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.


\subsubsection{分析}
無


\subsubsection{遞歸版}
遞歸版
\begin{Code}
// LeetCode, Same Tree
// 遞歸版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        if (!p && !q) return true;   // 終止條件
        if (!p || !q) return false;  // 剪枝
        return p->val == q->val      // 三方合併
                && isSameTree(p->left, q->left)
                && isSameTree(p->right, q->right);
    }
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
// LeetCode, Same Tree
// 迭代版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    bool isSameTree(TreeNode *p, TreeNode *q) {
        stack<TreeNode*> s;
        s.push(p);
        s.push(q);

        while(!s.empty()) {
            p = s.top(); s.pop();
            q = s.top(); s.pop();

            if (!p && !q) continue;
            if (!p || !q) return false;
            if (p->val != q->val) return false;

            s.push(p->left);
            s.push(q->left);

            s.push(p->right);
            s.push(q->right);
        }
        return true;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Symmetric Tree，見 \S \ref{sec:symmetric-tree}
\myenddot

\subsection{Count Univalue Subtrees}
\label{sec:count-univalue-subtrees}


\subsubsection{描述}
Given a binary tree, count the number of uni-value subtrees.

A Uni-value subtree means all nodes of the subtree have the same value.

Example:

\begin{Code}
Input:  root = [5,1,5,5,5,null,5]

              5
             / \
            1   5
           / \   \
          5   5   5

Output: 4
\end{Code}

\subsubsection{分析}
無

\subsubsection{Pass Parent Values}
\begin{Code}
// LeetCode
// 迭代版，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    int countUnivalSubtrees(TreeNode* root) {
        if (root == nullptr) return 0;

        int count = 0;
        DFS(root, count, root->val - 1);

        return count;
    }
private:
    bool DFS(TreeNode *root, int& count, int parVal) {
        if (root == nullptr) return true;

        int leftCount, rightCount; leftCount = rightCount = 0;
        bool isLeftUni = DFS(root->left, leftCount, root->val);
        bool isRightUni = DFS(root->right, rightCount, root->val);

        count += leftCount + rightCount;

        if (!isLeftUni || !isRightUni) return false;

        count++;

        return root->val == parVal;
    }
};
\end{Code}

\subsubsection{遞歸版}
\begin{Code}
// LeetCode
// 迭代版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    int countUnivalSubtrees(TreeNode* root) {
        if (root == nullptr) return 0;

        int uniCount = 0;
        bool uniTrue = false;
        countUnivalSubtrees(root, uniCount, uniTrue);

        return uniCount;
    }
private:
    void countUnivalSubtrees(TreeNode *root, int& uniCount, bool& uniTrue) {
        if (root == nullptr) {
            uniCount = 0;
            uniTrue = false;
        }
        else if (root->left == nullptr && root->right == nullptr) {
            uniCount = 1;
            uniTrue = true;
        }
        else {
            int uniLeft, uniRight; uniLeft = uniRight = 0;
            bool isUniLeft, isUniRight; isUniLeft = isUniRight = false;
            countUnivalSubtrees(root->left, uniLeft, isUniLeft);
            countUnivalSubtrees(root->right, uniRight, isUniRight);

            // 三方比較
            if (root->left && root->right
               && (root->val == root->left->val && isUniLeft)
               && (root->val == root->right->val && isUniRight)) {
                uniLeft++;
                uniTrue = true;
            }
            else if (root->left && root->right == nullptr
                     && root->val == root->left->val && isUniLeft)
            { uniLeft++; uniTrue = true; } // 左邊比較
            else if (root->left == nullptr && root->right
                     && root->val == root->right->val && isUniRight)
            { uniRight++; uniTrue = true; } // 右邊比較

            uniCount = uniLeft + uniRight;
        }
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Same Tree，見 \S \ref{sec:same-tree}
\myenddot

\subsection{Lowest Common Ancestor of Binary Tree}
\label{sec:lowest-common-ancestor-of-binary-tree}


\subsubsection{描述}
Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given the following binary tree:  root = [3,5,1,6,2,0,8,null,null,7,4]

\begin{center}
\includegraphics[width=100pt]{lowest-common-ancestor.png}\\
\figcaption{Loest common ancestor}\label{fig:lowest-common-ancestor}
\end{center}

Example 1:
\begin{Code}
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1
Output: 3
Explanation: The LCA of nodes 5 and 1 is 3.
\end{Code}


Example 2:
\begin{Code}
Input: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4
Output: 5
Explanation: The LCA of nodes 5 and 4 is 5
, since a node can be a descendant of itself according to the LCA definition.
\end{Code}

\subsubsection{分析}
無


\subsubsection{遞歸版}
\begin{Code}
// LeetCode
// 遞歸版，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        if (root == nullptr) return root;
        if (root == p || root == q) return root;

        TreeNode *left = lowestCommonAncestor(root->left, p, q);
        TreeNode *right = lowestCommonAncestor(root->right, p, q);

        if (left && right) return root;
        else if (!left) return right;
        else return left;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Same Tree，見 \S \ref{sec:same-tree}
\myenddot


\subsection{Symmetric Tree}
\label{sec:symmetric-tree}


\subsubsection{描述}
Given two binary trees, write a function to check if they are equal or not.

Two binary trees are considered equal if they are structurally identical and the nodes have the same value.


\subsubsection{分析}
無


\subsubsection{遞歸版}
\begin{Code}
// LeetCode, Symmetric Tree
// 遞歸版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    bool isSymmetric(TreeNode *root) {
        if (root == nullptr) return true;
        return isSymmetric(root->left, root->right);
    }
    bool isSymmetric(TreeNode *p, TreeNode *q) {
        if (p == nullptr && q == nullptr) return true;   // 終止條件
        if (p == nullptr || q == nullptr) return false;  // 終止條件
        return p->val == q->val      // 三方合併
                && isSymmetric(p->left, q->right)
                && isSymmetric(p->right, q->left);
    }
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
// LeetCode, Symmetric Tree
// 迭代版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    bool isSymmetric (TreeNode* root) {
        if (!root) return true;

        stack<TreeNode*> s;
        s.push(root->left);
        s.push(root->right);

        while (!s.empty ()) {
            auto p = s.top (); s.pop();
            auto q = s.top (); s.pop();

            if (!p && !q) continue;
            if (!p || !q) return false;
            if (p->val != q->val) return false;

            s.push(p->left);
            s.push(q->right);

            s.push(p->right);
            s.push(q->left);
        }

        return true;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Same Tree，見 \S \ref{sec:same-tree}
\myenddot


\subsection{Balanced Binary Tree}
\label{sec:balanced-binary-tree}


\subsubsection{描述}
Given a binary tree, determine if it is height-balanced.

For this problem, a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.


\subsubsection{分析}
無


\subsubsection{代碼}
\begin{Code}
// LeetCode, Balanced Binary Tree
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    bool isBalanced (TreeNode* root) {
        return balancedHeight (root) >= 0;
    }

    /**
     * Returns the height of `root` if `root` is a balanced tree,
     * otherwise, returns `-1`.
     */
    int balancedHeight (TreeNode* root) {
        if (root == nullptr) return 0;  // 終止條件

        int left = balancedHeight (root->left);
        int right = balancedHeight (root->right);

        if (left < 0 || right < 0 || abs(left - right) > 1) return -1;  // 剪枝

        return max(left, right) + 1; // 三方合併
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item 無
\myenddot


\subsection{Flatten Binary Tree to Linked List}
\label{sec:flatten-binary-tree-to-linked-list}


\subsubsection{描述}
Given a binary tree, flatten it to a linked list in-place.

For example, Given
\begin{Code}
         1
        / \
       2   5
      / \   \
     3   4   6
\end{Code}

The flattened tree should look like:
\begin{Code}
   1
    \
     2
      \
       3
        \
         4
          \
           5
            \
             6
\end{Code}

\subsubsection{分析}
無


\subsubsection{遞歸版1}
\begin{Code}
// LeetCode, Flatten Binary Tree to Linked List
// 遞歸版1，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    void flatten(TreeNode *root) {
        if (root == nullptr) return;  // 終止條件

        flatten(root->left);
        flatten(root->right);

        if (nullptr == root->left) return;

        // 三方合併，將左子樹所形成的鏈表插入到root和root->right之間
        TreeNode *p = root->left;
        while(p->right) p = p->right; //尋找左鏈表最後一個節點
        p->right = root->right;
        root->right = root->left;
        root->left = nullptr;
    }
};
\end{Code}


\subsubsection{遞歸版2}
\begin{Code}
// LeetCode, Flatten Binary Tree to Linked List
// 遞歸版2
// @author 王順達(http://weibo.com/u/1234984145)
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    void flatten(TreeNode *root) {
        flatten(root, NULL);
    }
private:
    // 把root所代表樹變成鏈表後，tail跟在該鏈表後面
    TreeNode *flatten(TreeNode *root, TreeNode *tail) {
        if (NULL == root) return tail;

        root->right = flatten(root->left, flatten(root->right, tail));
        root->left = NULL;
        return root;
    }
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
// LeetCode, Flatten Binary Tree to Linked List
// 迭代版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    void flatten(TreeNode* root) {
        if (root == nullptr) return;

        stack<TreeNode*> s;
        s.push(root);

        while (!s.empty()) {
            auto p = s.top();
            s.pop();

            if (p->right)
                s.push(p->right);
            if (p->left)
                s.push(p->left);

            p->left = nullptr;
            if (!s.empty())
                p->right = s.top();
        }
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item 無
\myenddot


\subsection{Populating Next Right Pointers in Each Node II} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:populating-next-right-pointers-in-each-node-ii}


\subsubsection{描述}
Follow up for problem "Populating Next Right Pointers in Each Node".

What if the given tree could be any binary tree? Would your previous solution still work?

Note: You may only use constant extra space.

For example,
Given the following binary tree,
\begin{Code}
         1
       /  \
      2    3
     / \    \
    4   5    7
\end{Code}

After calling your function, the tree should look like:
\begin{Code}
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \    \
    4-> 5 -> 7 -> NULL
\end{Code}


\subsubsection{分析}
要處理一個節點，可能需要最右邊的兄弟節點，首先想到用廣搜。但廣搜不是常數空間的，本題要求常數空間。

注意，這題的代碼原封不動，也可以解決 Populating Next Right Pointers in Each Node I.


\subsubsection{遞歸版}
\begin{Code}
// LeetCode, Populating Next Right Pointers in Each Node II
// 時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    void connect(TreeLinkNode *root) {
        if (root == nullptr) return;

        TreeLinkNode dummy(-1);
        for (TreeLinkNode *curr = root, *prev = &dummy; 
                curr; curr = curr->next) {
            if (curr->left != nullptr){
                prev->next = curr->left;
                prev = prev->next;
            }
            if (curr->right != nullptr){
                prev->next = curr->right;
                prev = prev->next;
            }
        }
        connect(dummy.next);
    }
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
// LeetCode, Populating Next Right Pointers in Each Node II
// 時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    void connect(TreeLinkNode *root) {
        while (root) {
            TreeLinkNode * next = nullptr; // the first node of next level
            TreeLinkNode * prev = nullptr; // previous node on the same level
            for (; root; root = root->next) {
                if (!next) next = root->left ? root->left : root->right;

                if (root->left) {
                    if (prev) prev->next = root->left;
                    prev = root->left;
                }
                if (root->right) {
                    if (prev) prev->next = root->right;
                    prev = root->right;
                }
            }
            root = next; // turn to next level
        }
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Populating Next Right Pointers in Each Node，見 \S \ref{sec:populating-next-right-pointers-in-each-node}
\myenddot

\subsection{Find Duplicate Subtrees} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:find-duplicate-subtrees}


\subsubsection{描述}
Given a binary tree, return all duplicate subtrees. For each kind of duplicate subtrees, you only need to return the root node of any one of them.

Two trees are duplicate if they have the same structure with same node values.

Example 1:
\begin{Code}
        1
       / \
      2   3
     /   / \
    4   2   4
       /
      4
\end{Code}

The following are two duplicate subtrees:
\begin{Code}
      2
     /
    4
\end{Code}

\begin{Code}
    4
\end{Code}

\subsubsection{遞歸版}
\begin{Code}
// 時間複雜度O(n^2)，空間複雜度O(n^2)
class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        unordered_map<string, int> cache;
        vector<TreeNode*> result;
        DFS(root, cache, result);

        return result;
    }
private:
    string DFS(TreeNode *root, unordered_map<string, int>& cache, vector<TreeNode*>& result)
    {
        if (!root) return "#";
        string serial = to_string(root->val) + "," + DFS(root->left, cache, result)
            + "," + DFS(root->right, cache, result);
        cache[serial]++;
        if (cache[serial] == 2)
            result.push_back(root);
        return serial;
    }
};
\end{Code}

\subsubsection{遞歸版}
\begin{Code}
// 時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        unordered_map<size_t, int> cache;
        vector<TreeNode*> result;
        DFS(root, cache, result);

        return result;
    }
private:
    string DFS(TreeNode *root, unordered_map<size_t, int>& cache, vector<TreeNode*>& result)
    {
        if (!root) return "#";
        string serial = to_string(root->val) + "," + DFS(root->left, cache, result)
            + "," + DFS(root->right, cache, result);
        // 直接算 uid
        size_t uid = hash<string>{}(serial);
        cache[uid]++;
        if (cache[uid] == 2)
            result.push_back(root);
        // return uid 減少計算
        return to_string(uid);
    }
};
\end{Code}



\section{二叉樹的構建} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Construct Binary Tree from Preorder and Inorder Traversal}
\label{sec:construct-binary-tree-from-preorder-and-inorder-traversal}


\subsubsection{描述}
Given preorder and inorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.


\subsubsection{分析}
\begin{Code}
          1
      /       \
     2         3
   /   \     /   \
  4    5    6    7
 /    / \       / \
8    9  10     11 12
\end{Code}
\begin{Code}
Preorder:  1 2 4 8 5 9 10 3 6 7 11 12
Inorder:   8 4 2 9 5 10 1 6 3 11 7 12
Postorder: 8 4 9 10 5 2 6 11 12 7 3 1
\end{Code}


\subsubsection{代碼}
\begin{Code}
// LeetCode, Construct Binary Tree from Preorder and Inorder Traversal
// 遞歸，時間複雜度O(n)，空間複雜度O(\logn)
class Solution {
public:
    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {
        return buildTree(begin(preorder), end(preorder),
                begin(inorder), end(inorder));
    }

    template<typename InputIterator>
    TreeNode* buildTree(InputIterator pre_first, InputIterator pre_last,
            InputIterator in_first, InputIterator in_last) {
        if (pre_first == pre_last) return nullptr;
        if (in_first == in_last) return nullptr;

        auto root = new TreeNode(*pre_first);

        auto inRootPos = find(in_first, in_last, *pre_first);
        auto leftSize = distance(in_first, inRootPos);
        auto preLeftLast = next(pre_first, leftSize + 1);
        // next(in_first, leftSize) == inRootPos

        root->left = buildTree(next(pre_first), preLeftLast, in_first, inRootPos);
        root->right = buildTree(preLeftLast, pre_last, next(inRootPos), in_last);

        return root;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Construct Binary Tree from Inorder and Postorder Traversal，見 \S \ref{sec:construct-binary-tree-from-inorder-and-postorder-traversal}
\myenddot


\subsection{Construct Binary Tree from Inorder and Postorder Traversal}
\label{sec:construct-binary-tree-from-inorder-and-postorder-traversal}


\subsubsection{描述}
Given inorder and postorder traversal of a tree, construct the binary tree.

Note:
You may assume that duplicates do not exist in the tree.


\subsubsection{分析}
\begin{Code}
          1
      /       \
     2         3
   /   \     /   \
  4    5    6    7
 /    / \       / \
8    9  10     11 12
\end{Code}
\begin{Code}
Preorder:  1 2 4 8 5 9 10 3 6 7 11 12
Inorder:   8 4 2 9 5 10 1 6 3 11 7 12
Postorder: 8 4 9 10 5 2 6 11 12 7 3 1
\end{Code}


\subsubsection{代碼}
\begin{Code}
// LeetCode, Construct Binary Tree from Inorder and Postorder Traversal
// 遞歸，時間複雜度O(n)，空間複雜度O(\logn)
class Solution {
public:
    TreeNode* buildTree(vector<int>& inorder, vector<int>& postorder) {
        return buildTree(begin(inorder), end(inorder),
                begin(postorder), end(postorder));
    }

    template<typename BidiIt>
    TreeNode* buildTree(BidiIt in_first, BidiIt in_last,
            BidiIt post_first, BidiIt post_last) {
        if (in_first ==in_last) return nullptr;
        if (post_first == post_last) return nullptr;

        const auto val = *prev(post_last);
        TreeNode* root = new TreeNode(val);

        auto inRootPos = find(in_first, in_last, val);
        auto leftSize = distance(in_first, inRootPos);
        auto postLeftLast = next(post_first, leftSize);

        root->left = buildTree(in_first, inRootPos, post_first, postLeftLast);
        root->right = buildTree(next(inRootPos), in_last, postLeftLast, prev(post_last));

        return root;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Construct Binary Tree from Preorder and Inorder Traversal，見 \S \ref{sec:construct-binary-tree-from-preorder-and-inorder-traversal}
\myenddot

\subsection{Serialize and Deserialize Binary Tree}
\label{sec:serialize-and-deserialize-binary-tree}


\subsubsection{描述}
Serialization is the process of converting a data structure or object into a sequence of bits so that it can be stored in a file or memory buffer, or transmitted across a network connection link to be reconstructed later in the same or another computer environment.

Design an algorithm to serialize and deserialize a binary tree. There is no restriction on how your serialization/deserialization algorithm should work. You just need to ensure that a binary tree can be serialized to a string and this string can be deserialized to the original tree structure.

Example:
\begin{Code}
You may serialize the following tree:

    1
   / \
  2   3
     / \
    4   5

as "[1,2,3,null,null,4,5]"
\end{Code}

\subsubsection{分析}
無


\subsubsection{遞歸版}
\begin{Code}
// LeetCode
// 時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        string result;
        serialize(root, result);
        return result;
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        list<string> parts = SplitParts(data, ',');

        return deserialize(parts);
    }
private:
    void serialize(TreeNode *root, string& result) {
        if (root == nullptr)
            result += "null,";
        else {
            result += to_string(root->val) + ",";
            serialize(root->left, result);
            serialize(root->right, result);
        }
    }
    TreeNode *deserialize(list<string>& parts) {
        if (parts.front() == "null") {
            parts.pop_front();
            return nullptr;
        }
        else {
            TreeNode *root = new TreeNode(StringToInt(parts.front()));
            parts.pop_front();
            root->left = deserialize(parts);
            root->right = deserialize(parts);

            return root;
        }
    }
    list<string> SplitParts(const string& str, char deli) {
        list<string> result;
        for (auto i = str.begin(); i < str.end();) {
            auto j = find(i, str.end(), deli);

            result.push_back(string(i, j));
            i = next(j);
        }
        return result;
    }
    int StringToInt(string num) {
        if (num.size() == 0) return 0;
        if (num[0] == '-')
            return -1 * stoi(num.substr(1));
        else
            return stoi(num);
    }
};
\end{Code}

\subsubsection{迭代 - BFS with queue}
\begin{Code}
// LeetCode
// 時間複雜度O(n)，空間複雜度O(n)
class Solution {
public:
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        stringstream result;
        if (root == nullptr) return result.str();

        queue<TreeNode*> cur;
        cur.push(root);
        while (!cur.empty()) {
            TreeNode *p = cur.front();
            cur.pop();

            if (p == nullptr) {
                result << "null,";
                continue;
            }
            else
                result << p->val << ",";

            cur.push(p->left);
            cur.push(p->right);
        }
        return result.str();
    }

    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data.size() == 0) return nullptr;

        auto i = find(data.begin(), data.end(), ',');

        queue<TreeNode*> cur;
        // 製造 root
        TreeNode *root = new TreeNode(StringToInt(string(data.begin(), i)));
        i = next(i);
        cur.push(root);

        while (!cur.empty()) {
            TreeNode *p = cur.front();
            cur.pop();

            // 取兩個值，一個為左，一個為右
            // 左
            if (i >= data.end()) continue;
            auto j = find(i, data.end(), ',');
            string nextStr = string(i, j);
            if (nextStr != "null")
                p->left = new TreeNode(StringToInt(nextStr));
            i = next(j);

            // 右
            if (i >= data.end()) continue;
            j = find(i, data.end(), ',');
            nextStr = string(i, j);
            if (nextStr != "null")
                p->right = new TreeNode(StringToInt(nextStr));
            i = next(j);

            // 處理下一層
            if (p->left) cur.push(p->left);
            if (p->right) cur.push(p->right);
        }

        return root;
    }
private:
    int StringToInt(string num) {
        if (num.size() == 0) return 0;
        if (num[0] == '-')
            return -1 * stoi(num.substr(1));
        else
            return stoi(num);
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Construct Binary Tree from Inorder and Postorder Traversal，見 \S \ref{sec:construct-binary-tree-from-inorder-and-postorder-traversal}
\myenddot



\section{二叉查找樹} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Unique Binary Search Trees}
\label{sec:unique-binary-search-trees}


\subsubsection{描述}
Given $n$, how many structurally unique BST's (binary search trees) that store values $1...n$?

For example,
Given $n = 3$, there are a total of 5 unique BST's.
\begin{Code}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
\end{Code}

\subsubsection{分析}
如果把上例的順序改一下，就可以看出規律了。
\begin{Code}
 1       1           2          3       3
  \       \         / \        /       / 
   3       2       1   3      2       1
  /         \                /         \
2            3              1           2
\end{Code}

比如，以1為根的樹的個數，等於左子樹的個數乘以右子樹的個數，左子樹是0個元素的樹，右子樹是2個元素的樹。以2為根的樹的個數，等於左子樹的個數乘以右子樹的個數，左子樹是1個元素的樹，右子樹也是1個元素的樹。依此類推。

當數組為 $1,2,3,...,n$時，基於以下原則的構建的BST樹具有唯一性：
\textbf{以i為根節點的樹，其左子樹由[1, i-1]構成， 其右子樹由[i+1, n]構成。}

定義$f(i)$為以$[1,i]$能產生的Unique Binary Search Tree的數目，則

如果數組為空，毫無疑問，只有一種BST，即空樹，$f(0)=1$。

如果數組僅有一個元素{1}，只有一種BST，單個節點，$f(1)=1$。

如果數組有兩個元素{1,2}， 那麼有如下兩種可能
\begin{Code}
1             2
  \          /
    2      1
\end{Code}

\begin{eqnarray}
f(2) &=& f(0) * f(1)   \text{ ，1為根的情況} \nonumber \\
     &+& f(1) * f(0)   \text{ ，2為根的情況} \nonumber
\end{eqnarray}

再看一看3個元素的數組，可以發現BST的取值方式如下：
\begin{eqnarray}
f(3) &=& f(0) * f(2)   \text{ ，1為根的情況} \nonumber \\
     &+& f(1) * f(1)   \text{ ，2為根的情況} \nonumber \\
     &+& f(2) * f(0)   \text{ ，3為根的情況} \nonumber
\end{eqnarray}

所以，由此觀察，可以得出$f$的遞推公式為
$$
f(i) = \sum_{k=1}^{i} f(k-1) \times f(i-k)
$$
至此，問題劃歸為一維動態規劃。


\subsubsection{代碼}

\begin{Code}
// LeetCode, Unique Binary Search Trees
// 時間複雜度O(n^2)，空間複雜度O(n)
class Solution {
public:
    int numTrees(int n) {
        vector<int> f(n + 1, 0);

        f[0] = 1;
        f[1] = 1;
        for (int i = 2; i <= n; ++i) {
            for (int k = 1; k <= i; ++k)
                f[i] += f[k-1] * f[i - k];
        }

        return f[n];
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Unique Binary Search Trees II，見 \S \ref{sec:unique-binary-search-trees-ii}
\myenddot


\subsection{Unique Binary Search Trees II}
\label{sec:unique-binary-search-trees-ii}


\subsubsection{描述}
Given $n$, generate all structurally unique BST's (binary search trees) that store values 1...n.

For example,
Given $n = 3$, your program should return all 5 unique BST's shown below.
\begin{Code}
   1         3     3      2      1
    \       /     /      / \      \
     3     2     1      1   3      2
    /     /       \                 \
   2     1         2                 3
\end{Code}


\subsubsection{分析}
見前面一題。


\subsubsection{代碼}

\begin{Code}
// LeetCode, Unique Binary Search Trees II
// 時間複雜度TODO，空間複雜度TODO
class Solution {
public:
    vector<TreeNode *> generateTrees(int n) {
        if (n == 0) return generate(1, 0);
        return generate(1, n);
    }
private:
    vector<TreeNode *> generate(int start, int end) {
        vector<TreeNode*> subTree;
        if (start > end) {
            subTree.push_back(nullptr);
            return subTree;
        }
        for (int k = start; k <= end; k++) {
            vector<TreeNode*> leftSubs = generate(start, k - 1);
            vector<TreeNode*> rightSubs = generate(k + 1, end);
            for (auto i : leftSubs) {
                for (auto j : rightSubs) {
                    TreeNode *node = new TreeNode(k);
                    node->left = i;
                    node->right = j;
                    subTree.push_back(node);
                }
            }
        }
        return subTree;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Unique Binary Search Trees，見 \S \ref{sec:unique-binary-search-trees}
\myenddot


\subsection{Validate Binary Search Tree}
\label{sec:validate-binary-search-tree}


\subsubsection{描述}
Given a binary tree, determine if it is a valid binary search tree (BST).

Assume a BST is defined as follows:
\begindot
\item The left subtree of a node contains only nodes with keys less than the node's key.
\item The right subtree of a node contains only nodes with keys greater than the node's key.
\item Both the left and right subtrees must also be binary search trees.
\myenddot


\subsubsection{分析}


\subsubsection{代碼}

\begin{Code}
// Validate Binary Search Tree
// 時間複雜度O(n)，空間複雜度O(\logn)
class Solution {
public:
    bool isValidBST(TreeNode* root) {
        return isValidBST(root, LONG_MIN, LONG_MAX);
    }

    bool isValidBST(TreeNode* root, long long lower, long long upper) {
        if (root == nullptr) return true;

        return root->val > lower && root->val < upper
                && isValidBST(root->left, lower, root->val)
                && isValidBST(root->right, root->val, upper);
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Validate Binary Search Tree，見 \S \ref{sec:validate-binary-search-tree}
\myenddot


\subsection{Convert Sorted Array to Binary Search Tree}
\label{sec:convert-sorted-array-to-binary-search-tree}


\subsubsection{描述}
Given an array where elements are sorted in ascending order, convert it to a height balanced BST.


\subsubsection{分析}
二分法。


\subsubsection{代碼}

\begin{Code}
// LeetCode, Convert Sorted Array to Binary Search Tree
// 分治法，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    TreeNode* sortedArrayToBST (vector<int>& num) {
        return sortedArrayToBST(num.begin(), num.end());
    }

    template<typename RandomAccessIterator>
    TreeNode* sortedArrayToBST (RandomAccessIterator first,
            RandomAccessIterator last) {
        const auto length = distance(first, last);

        if (length <= 0) return nullptr;  // 終止條件

        // 三方合併
        auto mid = first + length / 2;
        TreeNode* root = new TreeNode (*mid);
        root->left = sortedArrayToBST(first, mid);
        root->right = sortedArrayToBST(mid + 1, last);

        return root;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Convert Sorted List to Binary Search Tree，見 \S \ref{sec:convert-sorted-list-to-binary-search-tree}
\myenddot


\subsection{Convert Sorted List to Binary Search Tree}
\label{sec:convert-sorted-list-to-binary-search-tree}


\subsubsection{描述}
Given a singly linked list where elements are sorted in ascending order, convert it to a height balanced BST.


\subsubsection{分析}
這題與上一題類似，但是單鏈表不能隨機訪問，而自頂向下的二分法必須需要RandomAccessIterator，因此前面的方法不適用本題。

存在一種自底向上(bottom-up)的方法，見\myurl{http://leetcode.com/2010/11/convert-sorted-list-to-balanced-binary.html}


\subsubsection{分治法，自頂向下}
分治法，類似於 Convert Sorted Array to Binary Search Tree，自頂向下，複雜度$O(n\log n)$。
\begin{Code}
// LeetCode, Convert Sorted List to Binary Search Tree
// 分治法，類似於 Convert Sorted Array to Binary Search Tree，
// 自頂向下，時間複雜度O(n^2)，空間複雜度O(logn)
class Solution {
public:
    TreeNode* sortedListToBST (ListNode* head) {
        return sortedListToBST (head, listLength (head));
    }

    TreeNode* sortedListToBST (ListNode* head, int len) {
        if (len == 0) return nullptr;
        if (len == 1) return new TreeNode (head->val);

        TreeNode* root = new TreeNode (nth_node (head, len / 2 + 1)->val);
        root->left = sortedListToBST (head, len / 2);
        root->right = sortedListToBST (nth_node (head, len / 2 + 2), 
                (len - 1) / 2);

        return root;
    }

    int listLength (ListNode* node) {
        int n = 0;

        while(node) {
            ++n;
            node = node->next;
        }

        return n;
    }

    ListNode* nth_node (ListNode* node, int n) {
        while (--n)
            node = node->next;

        return node;
    }
};
\end{Code}


\subsubsection{自底向上}
\begin{Code}
// LeetCode, Convert Sorted List to Binary Search Tree
// bottom-up，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    TreeNode *sortedListToBST(ListNode *head) {
        int len = 0;
        ListNode *p = head;
        while (p) {
            len++;
            p = p->next;
        }
        return sortedListToBST(head, 0, len - 1);
    }
private:
    TreeNode* sortedListToBST(ListNode*& list, int start, int end) {
        if (start > end) return nullptr;

        int mid = start + (end - start) / 2;
        TreeNode *leftChild = sortedListToBST(list, start, mid - 1);
        TreeNode *parent = new TreeNode(list->val);
        parent->left = leftChild;
        list = list->next;
        parent->right = sortedListToBST(list, mid + 1, end);
        return parent;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Convert Sorted Array to Binary Search Tree，見 \S \ref{sec:convert-sorted-array-to-binary-search-tree}
\myenddot

\subsection{Inorder Successor in BST}
\label{sec:inorder-successor-in-bst}

\subsubsection{描述}
Given a binary search tree and a node in it, find the in-order successor of that node in the BST.

The successor of a node p is the node with the smallest key greater than p.val.

\subsubsection{分析}
Using Inorder travel

\subsubsection{代碼}
\begin{Code}
// LeetCode
// 時間複雜度O()，空間複雜度O()
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        if (root == nullptr) return root;

        return DFS(root, p);
    }
private:
    TreeNode *m_prev;

    TreeNode *DFS(TreeNode *root, TreeNode *p)
    {
        if (root == nullptr) return root;

        TreeNode *ansLeft = DFS(root->left, p);

        if (ansLeft != nullptr) return ansLeft;
        if (m_prev == p) return root;
        m_prev = root;

        return DFS(root->right, p);
    }
};
\end{Code}


\subsubsection{代碼}
\begin{Code}
// LeetCode
// 時間複雜度O()，空間複雜度O()
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        if (!root) return root;

        stack<TreeNode*> cache;
        TreeNode *cur = root;
        TreeNode *prev = nullptr;
        while (!cache.empty() || cur != nullptr)
        {
            if (cur != nullptr)
            {
                cache.push(cur);
                cur = cur->left;
            }
            else
            {
                if (prev == p)
                {
                    return cache.top();
                }
                else
                {
                    cur = cache.top();
                    cache.pop();

                    prev = cur;

                    cur = cur->right;
                }
            }
        }

        return nullptr;
    }
};
\end{Code}

\subsection{Binary Search Tree Iterator}
\label{sec:binary-search-tree-iterator}

\subsubsection{描述}
Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.

Calling next() will return the next smallest number in the BST.

\begin{center}
\includegraphics[width=300pt]{binary-search-tree-iterator.png}\\
\figcaption{Binary Search Tree Iterator}\label{fig:binary-search-tree-iterator}
\end{center}

\subsubsection{分析}
Using inorder

\subsubsection{代碼}
\begin{Code}
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class BSTIterator {
public:
    BSTIterator(TreeNode* root) {
        m_root = root;

        // 移到最左
        while (m_root != nullptr)
        {
            m_cache.push(m_root);
            m_root = m_root->left;
        }
    }

    /** @return the next smallest number */
    int next() {
        if (!m_cache.empty())
        {
            m_root = m_cache.top();
            m_cache.pop();
        }

        int val = m_root->val;

        m_root = m_root->right;
        // 移到最左
        while (m_root != nullptr)
        {
            m_cache.push(m_root);
            m_root = m_root->left;
        }

        return val;
    }

    /** @return whether we have a next smallest number */
    bool hasNext() {
        return !m_cache.empty();
    }
private:
    TreeNode *m_root;
    stack<TreeNode *> m_cache;
};
\end{Code}

\subsection{Search in a Binary Search Tree}
\label{sec:search-in-a-binary-search-tree}

\subsubsection{描述}
Given the root node of a binary search tree (BST) and a value. You need to find the node in the BST that the node's value equals the given value. Return the subtree rooted with that node. If such node doesn't exist, you should return NULL.

For Example:
\begin{Code}
Given the tree:
        4
       / \
      2   7
     / \
    1   3

And the value to search: 2
\end{Code}

You should return thie subtree:
\begin{Code}
      2     
     / \   
    1   3
\end{Code}


\subsubsection{代碼}
\begin{Code}
class Solution {
public:
    TreeNode* searchBST(TreeNode* root, int val) {
        if (root == nullptr) return nullptr;

        if (root->val == val) return root;

        if (root->val > val)
            return searchBST(root->left, val);
        else
            return searchBST(root->right, val);
    }
};
\end{Code}

\subsection{Insert into a Binary Search Tree}
\label{sec:insert-into-a-binary-search-tree}

\subsubsection{描述}
Given the root node of a binary search tree (BST) and a value to be inserted into the tree, insert the value into the BST. Return the root node of the BST after the insertion. It is guaranteed that the new value does not exist in the original BST.

Note that there may exist multiple valid ways for the insertion, as long as the tree remains a BST after insertion. You can return any of them.

For example:
\begin{Code}
Given the tree:
        4
       / \
      2   7
     / \
    1   3
And the value to insert: 5
\end{Code}

You can return this binary search tree:
\begin{Code}
         4
       /   \
      2     7
     / \   /
    1   3 5
\end{Code}

This tree is also valid:
\begin{Code}
         5
       /   \
      2     7
     / \   
    1   3
         \
          4
\end{Code}


\subsubsection{遞歸版}
\begin{Code}
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        if (root == nullptr) {
            return new TreeNode(val);   // return a new node if root is null
        }
        if (root->val < val) {           // insert to the right subtree if val > root->val
            root->right = insertIntoBST(root->right, val);
        } else {                        // insert to the left subtree if val <= root->val
            root->left = insertIntoBST(root->left, val);
        }
        return root;
    }
};
\end{Code}

\subsubsection{迭代版}
\begin{Code}
class Solution {
public:
    TreeNode* insertIntoBST(TreeNode* root, int val) {
        TreeNode *node = root;

        while (node != nullptr)
        {
            if (node->val < val)
            {
                if (node->right == nullptr)
                {
                    node->right = new TreeNode(val);
                    return root;
                }
                else
                    node = node->right;
            }
            else
            {
                if (node->left == nullptr)
                {
                    node->left = new TreeNode(val);
                    return root;
                }
                else
                    node = node->left;
            }
        }

        return new TreeNode(val);
    }
};
\end{Code}

\subsection{Delete Node in a BST}
\label{sec:delete-node-in-a-bst}

\subsubsection{描述}
Given a root node reference of a BST and a key, delete the node with the given key in the BST. Return the root node reference (possibly updated) of the BST.

Basically, the deletion can be divided into two stages:

\begindot
\item Search for a node to remove.
\item If the node is found, delete the node.
\myenddot

For Example:
\begin{Code}
root = [5,3,6,2,4,null,7]
key = 3

    5
   / \
  3   6
 / \   \
2   4   7

Given key to delete is 3. So we find the node with value 3 and delete it.

One valid answer is [5,4,6,2,null,null,7], shown in the following BST.

    5
   / \
  4   6
 /     \
2       7

Another valid answer is [5,2,6,null,4,null,7].

    5
   / \
  2   6
   \   \
    4   7
\end{Code}



\subsubsection{代碼}
\begin{Code}
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        // return null if root is null
        if (!root) {
            return root;
        }

        // delete current node if root is the target node
        if (root->val == key) {
            // replace root with root->right if root->left is null
            if (!root->left) {
                return root->right;
            }

            // replace root with root->left if root->right is null
            if (!root->right) {
                return root->left;
            }

            // replace root with its successor if root has two children
            TreeNode* p = findSuccessor(root);
            root->val = p->val;
            root->right = deleteNode(root->right, p->val);
            return root;
        }

        if (root->val < key) {
            // find target in right subtree if root->val < key
            root->right = deleteNode(root->right, key);
        } else {
            // find target in left subtree if root->val > key
            root->left = deleteNode(root->left, key);
        }
        return root;
    }
private:
    /**
     * findSuccesor - Helper function for finding successor
     * In BST, succesor of root is the leftmost child in root's right subtree
     */
    TreeNode* findSuccessor(TreeNode* root) {
        TreeNode* cur = root->right;
        while (cur && cur->left) {
            cur = cur->left;
        }
        return cur;
    }
};
\end{Code}

\subsection{Kth Largest Element in a Stream}
\label{sec:kth-largest-element-in-a-stream}

\subsubsection{描述}
Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.

Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.

Example:
\begin{Code}
int k = 3;
int[] arr = [4,5,8,2];
KthLargest kthLargest = new KthLargest(3, arr);
kthLargest.add(3);   // returns 4
kthLargest.add(5);   // returns 5
kthLargest.add(10);  // returns 5
kthLargest.add(9);   // returns 8
kthLargest.add(4);   // returns 8
\end{Code}

You may assume that nums' length $\leq$ k-1 and k $\leq$ 1

\subsubsection{Priority Queue}
\begin{Code}
// LeetCode
// 時間複雜度O()，空間複雜度O()
namespace std {
    struct SmallerThanInt {
        bool operator()(const int& first, const int& second) {
            return first > second;
        }
    };
}

class KthLargest {
public:
    KthLargest(int k, vector<int>& nums) {
        m_k = k;
        for (const int& n : nums)
        {
            if (m_data.size() < m_k)
                m_data.push(n);
            else
            {
                if (n > m_data.top())
                {
                    m_data.pop();
                    m_data.push(n);
                }
            }
        }
    }

    int add(int val) {
        if (m_data.size() == m_k && val < m_data.top()) return m_data.top();

        if (m_data.size() < m_k)
            m_data.push(val);
        else
        {
            if (val > m_data.top())
            {
                m_data.pop();
                m_data.push(val);
            }
        }

        return m_data.top();
    }
private:
    priority_queue<int, vector<int>, SmallerThanInt> m_data;
    int m_k;
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest* obj = new KthLargest(k, nums);
 * int param_1 = obj->add(val);
 */
\end{Code}

\subsubsection{BST method}
\begin{Code}
// LeetCode
// 時間複雜度O()，空間複雜度O()
struct Node {
    Node* left;
    Node* right;
    int val;
    int cnt;
    Node(int v, int c) : left(NULL), right(NULL), val(v), cnt(c) {}
};

class KthLargest {
private:
    Node* insertNode(Node* root, int num) {
        if (!root) {
            return new Node(num, 1);      // return a new node if root is null
        }
        if (root->val < num) {  // insert to the right subtree if val > root->val
            root->right = insertNode(root->right, num);
        } else {  // insert to the left subtree if val <= root->val
            root->left = insertNode(root->left, num);
        }
        root->cnt++;
        return root;
    }
    int searchKth(Node* root, int k) {
        // m = the size of right subtree
        int m = root->right ? (root->right)->cnt : 0;
        // root is the m+1 largest node in the BST
        if (k == m + 1) {
            return root->val;
        }
        if (k <= m) {
            // find kth largest in the right subtree
            return searchKth(root->right, k);
        } else {
            // find (k-m-1)th largest in the left subtree
            return searchKth(root->left, k - m - 1);
        }
    }
    Node* root;
    int m_k;
public:
    KthLargest(int k, vector<int> nums) {
        root = NULL;
        for (int i = 0; i < nums.size(); ++i) {
            root = insertNode(root, nums[i]);
        }
        m_k = k;
    }

    int add(int val) {
        root = insertNode(root, val);
        return searchKth(root, m_k);
    }
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest obj = new KthLargest(k, nums);
 * int param_1 = obj.add(val);
 */
\end{Code}

\subsubsection{Remake Heap - fastest}
\begin{Code}
// LeetCode
// 時間複雜度O()，空間複雜度O()
class KthLargest {
public:
    KthLargest(int k, vector<int>& nums) {
        m_k = k;
        m_data.resize(m_k, INT_MIN);

        m_index = 0;
        for (const auto& n : nums)
        {
            if (m_index < m_k)
                PushHeap(m_data.begin(), m_index++, 0, n);
            else
            {
                if (m_data.front() < n)
                    AdjustHeap(m_data.begin(), 0, m_k, n);
            }
        }
    }

    int add(int val) {
        if (m_index == m_k && m_data.front() > val) return m_data.front();

        if (m_index < m_k)
            PushHeap(m_data.begin(), m_index++, 0, val);
        else
            AdjustHeap(m_data.begin(), 0, m_k, val);

        return m_data.front();
    }
private:
    template <class RandIT, class Dist, class T>
        void PushHeap(RandIT first, Dist holeIndex, Dist topIndex, T data)
    {
        Dist parentIndex = (holeIndex - 1) / 2;
        while (holeIndex > topIndex && *next(first, parentIndex) > data)
        {
            *next(first, holeIndex) = *next(first, parentIndex);
            holeIndex = parentIndex;
            parentIndex = (holeIndex - 1) / 2;
        }
        *next(first, holeIndex) = data;
    }
    template <class RandIT, class Dist, class T>
        void AdjustHeap(RandIT first, Dist holeIndex, Dist Len, T data)
    {
        Dist topIndex = holeIndex;
        Dist childIndex = (holeIndex + 1) * 2;
        while (childIndex < Len)
        {
            if (*next(first, childIndex) > *next(first, childIndex-1))
                childIndex--;
            *next(first, holeIndex) = *next(first, childIndex);
            holeIndex = childIndex;
            childIndex = (holeIndex + 1) * 2;
        }
        if (childIndex == Len)
        {
            *next(first, holeIndex) = *next(first, childIndex-1);
            holeIndex = childIndex-1;
        }
        PushHeap(first, holeIndex, topIndex, data);
    }
private:
    vector<int> m_data;
    int m_k;
    int m_index;
};

/**
 * Your KthLargest object will be instantiated and called as such:
 * KthLargest* obj = new KthLargest(k, nums);
 * int param_1 = obj->add(val);
 */
\end{Code}

\subsection{Lowest Common Ancestor of a Binary Search Tree}
\label{sec:lowest-common-ancestor-of-a-binary-search-tree}

\subsubsection{描述}
Given a binary search tree (BST), find the lowest common ancestor (LCA) of two given nodes in the BST.

According to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”

Given binary search tree:  root = [6,2,8,0,4,7,9,null,null,3,5]

\begin{center}
\includegraphics[width=300pt]{binary-search-tree-improved.png}\\
\figcaption{Lowest Common Ancestor of a BST}\label{fig:binary-search-tree-improved}
\end{center}

Example 1:
\begin{Code}
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8
Output: 6
Explanation: The LCA of nodes 2 and 8 is 6.
\end{Code}

Example 2:
\begin{Code}
Input: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4
Output: 2
Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition.
\end{Code}

Note:
\begindot
\item All of the nodes' values will be unique.
\item p and q are different and both values will exist in the BST.
\myenddot

\subsubsection{Code}
\begin{Code}
class Solution {
public:
    TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
        while(root != NULL)
        {
            //If both nodes less than that of parent => move left
            if(root->val > p->val and root->val > q->val)
                root = root->left;
            //If both nodes greater than that of parent => move right
            else if(root->val < p->val and root->val < q->val)
                root = root->right;
            //If paths diverge then return node
            else
                return root;
        }

        return root;
    }
};
\end{Code}

\subsection{Contains Duplicate II}
\label{sec:contains-duplicate-ii}

\subsubsection{描述}
Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the absolute difference between i and j is at most k.

Example 1:
\begin{Code}
Input: nums = [1,2,3,1], k = 3
Output: true
\end{Code}

Example 2:
\begin{Code}
Input: nums = [1,0,1,1], k = 1
Output: true
\end{Code}

Example 3:
\begin{Code}
Input: nums = [1,2,3,1,2,3], k = 2
Output: false
\end{Code}

\subsubsection{Hash map}
\begin{Code}
// 時間複雜度O(n)，空間複雜度O(min(k,n))
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        if (nums.size() == 0) return false;
        if (k == 0) return false;
        unordered_set<int> cache;

        for (size_t i = 0; i < nums.size(); i++)
        {
            if (cache.find(nums[i]) != cache.end()) return true;

            if (cache.size() >= k)
                cache.erase(nums[i-k]);
            cache.insert(nums[i]);
        }

        return false;
    }
};
\end{Code}


\subsection{Contains Duplicate III}
\label{sec:contains-duplicate-iii}

\subsubsection{描述}
Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.


Example 1:
\begin{Code}
Input: nums = [1,2,3,1], k = 3, t = 0
Output: true
\end{Code}

Example 2:
\begin{Code}
Input: nums = [1,0,1,1], k = 1, t = 2
Output: true
\end{Code}

Example 3:
\begin{Code}
Input: nums = [1,5,9,1,5,9], k = 2, t = 3
Output: false
\end{Code}

\subsubsection{暴力方法}
\begin{Code}
// 時間複雜度O(n*min(k,n))，空間複雜度O(min(k,n))
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        for (int i = 0; i < nums.size(); i++)
        {
            // abs difference 會有機會大過 int32_t, 所以要用 int64_t
            // 例子: [-1,2147483647], k = 1, t = 2147483647
            for (int j = max(i - k, 0); j < i; j++)
                if (abs((int64_t)nums[i] - (int64_t)nums[j]) <= (int64_t)t) return true;
        }

        return false;
    }
};
\end{Code}

\subsubsection{BST method}
\begin{Code}
// 時間複雜度O(nlog(min(k,n)))，空間複雜度O(min(k,n))
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        set<int> cache;
        for (int i = 0; i < nums.size(); i++)
        {
            if (!cache.empty())
            {
                // 尋找當下數值的 successor
                auto s = GetCeiling(cache, cache.begin(), nums[i]);
                if (s != cache.end() && *s <= nums[i] + t) return true;

                // 尋找當下數值的 predecessor
                auto g = GetFloor(cache, cache.begin(), nums[i]);
                if (g != cache.end() && nums[i] <= *g + t) return true;
            }

            cache.insert(nums[i]);
            if (cache.size() > k)
                cache.erase(nums[i - k]);
        }
        return false;
    }
private:
    template <class BTS, class BidIT, class T>
        BidIT GetCeiling(BTS& tree, BidIT first, T val)
    {
        return tree.lower_bound(val);
    }
    template <class BTS, class BidIT, class T>
        BidIT GetFloor(BTS& tree, BidIT first, T val)
    {
        BidIT tmp = tree.upper_bound(val);
        if (tmp == tree.begin())
            return tree.end();
        else
            return prev(tmp);
    }
};
\end{Code}

\subsubsection{Bucket}
\begin{Code}
// 時間複雜度O(n)，空間複雜度O(min(k,n))
class Solution {
public:
    bool containsNearbyAlmostDuplicate(vector<int>& nums, int k, int t) {
        if (t < 0) return false;
        unordered_map<int64_t, int64_t> d;

        int64_t w = (int64_t)t + 1;
        for (int i = 0; i < nums.size(); i++)
        {
            int64_t id = GetId(nums[i], w);
            // 若果同一個 bucket 有多過一個數值，代表找到答案
            if (d.find(id) != d.end())
                return true;
            // 檢查前一個 bucket
            if (d.find(id-1) != d.end() && abs(nums[i] - d[id-1]) < w)
                return true;
            // 檢查後一個 bucket
            if (d.find(id+1) != d.end() && abs(nums[i] - d[id+1]) < w)
                return true;
            d[id] = (int64_t)nums[i];
            if (i >= k) d.erase(GetId(nums[i-k], w));
        }

        return false;
    }
private:
    // `-3 / 5 = 0` and but we need `-3 / 5 = -1`.
    int64_t GetId(int64_t x, int64_t w)
    {
        return x < 0 ? (x + 1) / w - 1 : x / w;
    }
};
\end{Code}

\section{二叉樹的遞歸} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
二叉樹是一個遞歸的數據結構，因此是一個用來考察遞歸思維能力的絕佳數據結構。

遞歸一定是深搜（見 \S \ref{sec:dfs-vs-recursion}節 “深搜與遞歸的區別”），由於在二叉樹上，遞歸的味道更濃些，因此本節用“二叉樹的遞歸”作為標題，而不是“二叉樹的深搜”，儘管本節所有的算法都屬於深搜。

二叉樹的先序、中序、後序遍歷都可以看做是DFS，此外還有其他順序的深度優先遍歷，共有$3!=6$種。其他3種順序是 \fn{root->r->l，r->root->l, r->l->root}。


\subsection{Minimum Depth of Binary Tree}
\label{sec:minimum-depth-of-binary-tree}


\subsubsection{描述}
Given a binary tree, find its minimum depth.

The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.


\subsubsection{分析}
無


\subsubsection{遞歸版}
\begin{Code}
// LeetCode, Minimum Depth of Binary Tree
// 遞歸版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    int minDepth(const TreeNode *root) {
        return minDepth(root, false);
    }
private:
    static int minDepth(const TreeNode *root, bool hasbrother) {
        if (!root) return hasbrother ? INT_MAX : 0;

        return 1 + min(minDepth(root->left, root->right != NULL),
                minDepth(root->right, root->left != NULL));
    }
};
\end{Code}


\subsubsection{迭代版}
\begin{Code}
// LeetCode, Minimum Depth of Binary Tree
// 迭代版，時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    int minDepth(TreeNode* root) {
        if (root == nullptr)
            return 0;

        int result = INT_MAX;

        stack<pair<TreeNode*, int>> s;
        s.push(make_pair(root, 1));

        while (!s.empty()) {
            auto node = s.top().first;
            auto depth = s.top().second;
            s.pop();

            if (node->left == nullptr && node->right == nullptr)
                result = min(result, depth);

            if (node->left && result > depth) // 深度控制，剪枝
                s.push(make_pair(node->left, depth + 1));

            if (node->right && result > depth) // 深度控制，剪枝
                s.push(make_pair(node->right, depth + 1));
        }

        return result;
    }
};
\end{Code}

\subsubsection{相關題目}
\begindot
\item Maximum Depth of Binary Tree，見 \S \ref{sec:maximum-depth-of-binary-tree}
\myenddot


\subsection{Maximum Depth of Binary Tree}
\label{sec:maximum-depth-of-binary-tree}


\subsubsection{描述}
Given a binary tree, find its maximum depth.

The maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node.


\subsubsection{分析}
無

\subsubsection{代碼}

\begin{Code}
// LeetCode, Maximum Depth of Binary Tree
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    int maxDepth(TreeNode *root) {
        if (root == nullptr) return 0;

        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Minimum Depth of Binary Tree，見 \S \ref{sec:minimum-depth-of-binary-tree}
\myenddot


\subsection{Path Sum}
\label{sec:path-sum}


\subsubsection{描述}
Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

For example:
Given the below binary tree and \code{sum = 22},
\begin{Code}
          5
         / \
        4   8
       /   / \
      11  13  4
     /  \      \
    7    2      1
\end{Code}
return true, as there exist a root-to-leaf path \code{5->4->11->2} which sum is 22.


\subsubsection{分析}
題目只要求返回\fn{true}或者\fn{false}，因此不需要記錄路徑。

由於只需要求出一個結果，因此，當左、右任意一棵子樹求到了滿意結果，都可以及時return。

由於題目沒有説節點的數據一定是正整數，必須要走到葉子節點才能判斷，因此中途沒法剪枝，只能進行樸素深搜。

\subsubsection{代碼}

\begin{Code}
// LeetCode, Path Sum
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    bool hasPathSum(TreeNode *root, int sum) {
        if (root == nullptr) return false;

        if (root->left == nullptr && root->right == nullptr) // leaf
            return sum == root->val;

        return hasPathSum(root->left, sum - root->val)
                || hasPathSum(root->right, sum - root->val);
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Path Sum II，見 \S \ref{sec:path-sum-ii}
\myenddot


\subsection{Path Sum II}
\label{sec:path-sum-ii}


\subsubsection{描述}
Given a binary tree and a sum, find all root-to-leaf paths where each path's sum equals the given sum.

For example:
Given the below binary tree and \code{sum = 22},
\begin{Code}
          5
         / \
        4   8
       /   / \
      11  13  4
     /  \    / \
    7    2  5   1
\end{Code}
return
\begin{Code}
[
   [5,4,11,2],
   [5,8,4,5]
]
\end{Code}


\subsubsection{分析}
跟上一題相比，本題是求路徑本身。且要求出所有結果，左子樹求到了滿意結果，不能return，要接着求右子樹。

\subsubsection{代碼}

\begin{Code}
// LeetCode, Path Sum II
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    vector<vector<int> > pathSum(TreeNode *root, int sum) {
        vector<vector<int> > result;
        vector<int> cur; // 中間結果
        pathSum(root, sum, cur, result);
        return result;
    }
private:
    void pathSum(TreeNode *root, int gap, vector<int> &cur,
            vector<vector<int> > &result) {
        if (root == nullptr) return;

        cur.push_back(root->val);

        if (root->left == nullptr && root->right == nullptr) { // leaf
            if (gap == root->val)
                result.push_back(cur);
        }
        pathSum(root->left, gap - root->val, cur, result);
        pathSum(root->right, gap - root->val, cur, result);

        cur.pop_back();
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Path Sum，見 \S \ref{sec:path-sum}
\myenddot


\subsection{Binary Tree Maximum Path Sum}
\label{sec:binary-tree-maximum-path-sum}


\subsubsection{描述}
Given a binary tree, find the maximum path sum.

The path may start and end at any node in the tree.
For example:
Given the below binary tree,
\begin{Code}
  1
 / \
2   3
\end{Code}
Return $6$.


\subsubsection{分析}
這題很難，路徑可以從任意節點開始，到任意節點結束。

可以利用“最大連續子序列和”問題的思路，見第\S \ref{sec:maximum-subarray}節。如果説Array只有一個方向的話，那麼Binary Tree其實只是左、右兩個方向而已，我們需要比較兩個方向上的值。

不過，Array可以從頭到尾遍歷，那麼Binary Tree怎麼辦呢，我們可以採用Binary Tree最常用的dfs來進行遍歷。先算出左右子樹的結果L和R，如果L大於0，那麼對後續結果是有利的，我們加上L，如果R大於0，對後續結果也是有利的，繼續加上R。

\subsubsection{代碼}

\begin{Code}
// LeetCode, Binary Tree Maximum Path Sum
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    int maxPathSum(TreeNode *root) {
        max_sum = INT_MIN;
        dfs(root);
        return max_sum;
    }
private:
    int max_sum;
    int dfs(const TreeNode *root) {
        if (root == nullptr) return 0;
        int l = dfs(root->left);
        int r = dfs(root->right);
        int sum = root->val;
        if (l > 0) sum += l;
        if (r > 0) sum += r;
        max_sum = max(max_sum, sum);
        return max(r, l) > 0 ? max(r, l) + root->val : root->val;
    }
};
\end{Code}

注意，最後return的時候，只返回一個方向上的值，為什麼？這是因為在遞歸中，只能向父節點返回，不可能存在L->root->R的路徑，只可能是L->root或R->root。


\subsubsection{相關題目}
\begindot
\item Maximum Subarray，見 \S \ref{sec:maximum-subarray}
\myenddot


\subsection{Populating Next Right Pointers in Each Node} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:populating-next-right-pointers-in-each-node}


\subsubsection{描述}
Given a binary tree
\begin{Code}
struct TreeLinkNode {
   int val;
   TreeLinkNode *left, *right, *next;
   TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
};
\end{Code}

Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to \fn{NULL}.

Initially, all next pointers are set to \fn{NULL}.

Note:
\begindot
\item You may only use constant extra space.
\item You may assume that it is a perfect binary tree (ie, all leaves are at the same level, and every parent has two children).
\myenddot

For example,
Given the following perfect binary tree,
\begin{Code}
         1
       /  \
      2    3
     / \  / \
    4  5  6  7
\end{Code}

After calling your function, the tree should look like:
\begin{Code}
         1 -> NULL
       /  \
      2 -> 3 -> NULL
     / \  / \
    4->5->6->7 -> NULL
\end{Code}


\subsubsection{分析}
無

\subsubsection{代碼}

\begin{Code}
// LeetCode, Populating Next Right Pointers in Each Node
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    void connect(TreeLinkNode *root) {
        connect(root, NULL);
    }
private:
    void connect(TreeLinkNode *root, TreeLinkNode *sibling) {
        if (root == nullptr)
            return;
        else
            root->next = sibling;

        connect(root->left, root->right);
        if (sibling)
            connect(root->right, sibling->left);
        else
            connect(root->right, nullptr);
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Populating Next Right Pointers in Each Node II，見 \S \ref{sec:populating-next-right-pointers-in-each-node-ii}
\myenddot


\subsection{Sum Root to Leaf Numbers} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:sum-root-to-leaf-numbers}


\subsubsection{描述}
Given a binary tree containing digits from \fn{0-9} only, each root-to-leaf path could represent a number.

An example is the root-to-leaf path \fn{1->2->3} which represents the number \fn{123}.

Find the total sum of all root-to-leaf numbers.

For example,
\begin{Code}
    1
   / \
  2   3
\end{Code}

The root-to-leaf path \fn{1->2} represents the number \fn{12}.
The root-to-leaf path \fn{1->3} represents the number \fn{13}.

Return the sum = \fn{12 + 13 = 25}.


\subsubsection{分析}
無

\subsubsection{代碼}

\begin{Code}
// LeetCode, Decode Ways
// 時間複雜度O(n)，空間複雜度O(logn)
class Solution {
public:
    int sumNumbers(TreeNode *root) {
        return dfs(root, 0);
    }
private:
    int dfs(TreeNode *root, int sum) {
        if (root == nullptr) return 0;
        if (root->left == nullptr && root->right == nullptr)
            return sum * 10 + root->val;

        return dfs(root->left, sum * 10 + root->val) +
                dfs(root->right, sum * 10 + root->val);
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item 無
\myenddot

\subsection{Convert Binary Search Tree To Double link list} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:convert-binary-search-tree-to-double-link-list}


\subsubsection{描述}
Convert a Binary Search Tree to a sorted Circular Doubly-Linked List in place.

You can think of the left and right pointers as synonymous to the predecessor and successor pointers in a doubly-linked list. For a circular doubly linked list, the predecessor of the first element is the last element, and the successor of the last element is the first element.

We want to do the transformation in place. After the transformation, the left pointer of the tree node should point to its predecessor, and the right pointer should point to its successor. You should return the pointer to the smallest element of the linked list.


\begin{center}
\includegraphics[width=300pt]{convert-binary-search-tree-to-double-link-list.png}\\
\figcaption{Convert Binary Search Tree}\label{fig:convert-binary-search-tree-to-double-link-list}
\end{center}
\subsubsection{分析}
無

\subsubsection{代碼}

\begin{Code}
// LeetCode, Decode Ways
// 時間複雜度O(n)，空間複雜度O(logn)
/*
// Definition for a Node.
class Node {
public:
    int val;
    Node* left;
    Node* right;

    Node() {}

    Node(int _val) {
        val = _val;
        left = NULL;
        right = NULL;
    }

    Node(int _val, Node* _left, Node* _right) {
        val = _val;
        left = _left;
        right = _right;
    }
};
*/

class Solution {
public:
    Node* treeToDoublyList(Node* root) {
        if (root == nullptr) return root;

        m_last = m_first = nullptr;

        DFS(root);
        m_first->left = m_last;
        m_last->right = m_first;

        return m_first;
    }
private:
    void DFS(Node *node)
    {
        if (node == nullptr) return;

        DFS(node->left);

        if (m_last)
        {
            m_last->right = node;
            node->left = m_last;
        }
        else
        {
            m_first = node;
            node->left = nullptr;
        }
        m_last = node;

        DFS(node->right);
    }
private:
    Node *m_last;
    Node *m_first;
};
\end{Code}
