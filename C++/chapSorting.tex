\chapter{排序}

\section{Merge Two Sorted Arrays} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:merge-two-sorted-arrays}


\subsubsection{描述}
Given two sorted integer arrays A and B, merge B into A as one sorted array.

Note:
You may assume that A has enough space to hold additional elements from B. The number of elements initialized in A and B are m and n respectively.


\subsubsection{分析}
無


\subsubsection{代碼}
\begin{Code}
//LeetCode, Merge Sorted Array
// 時間複雜度O(m+n)，空間複雜度O(1)
class Solution {
public:
    void merge(vector<int>& A, int m, vector<int>& B, int n) {
        int ia = m - 1, ib = n - 1, icur = m + n - 1;
        while(ia >= 0 && ib >= 0) {
            A[icur--] = A[ia] >= B[ib] ? A[ia--] : B[ib--];
        }
        while(ib >= 0) {
            A[icur--] = B[ib--];
        }
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Merge Two Sorted Lists，見 \S \ref{sec:merge-two-sorted-arrays}
\item Merge k Sorted Lists，見 \S \ref{sec:merge-k-sorted-lists}
\myenddot


\section{Merge Two Sorted Lists} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:merge-two-sorted-lists}


\subsubsection{描述}
Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.


\subsubsection{分析}
無


\subsubsection{代碼}
\begin{Code}
//LeetCode, Merge Two Sorted Lists
// 時間複雜度O(min(m,n))，空間複雜度O(1)
class Solution {
public:
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        if (l1 == nullptr) return l2;
        if (l2 == nullptr) return l1;
        ListNode dummy(-1);
        ListNode *p = &dummy;
        for (; l1 != nullptr && l2 != nullptr; p = p->next) {
            if (l1->val > l2->val) { p->next = l2; l2 = l2->next; }
            else { p->next = l1; l1 = l1->next; }
        }
        p->next = l1 != nullptr ? l1 : l2;
        return dummy.next;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Merge Sorted Array \S \ref{sec:merge-two-sorted-arrays}
\item Merge k Sorted Lists，見 \S \ref{sec:merge-k-sorted-lists}
\myenddot


\section{Merge k Sorted Lists} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:merge-k-sorted-lists}


\subsubsection{描述}
Merge k sorted linked lists and return it as one sorted list. Analyze and describe its complexity.


\subsubsection{分析}
可以複用Merge Two Sorted Lists（見 \S \ref{sec:merge-two-sorted-lists}）的函數


\subsubsection{代碼}
\begin{Code}
//LeetCode, Merge k Sorted Lists
// 時間複雜度O(n1+n2+...)，空間複雜度O(1)
class Solution {
public:

    ListNode * mergeTwo(ListNode * l1, ListNode * l2){
        if(!l1) return l2;
        if(!l2) return l1;
        ListNode dummy(-1);
        ListNode * p = &dummy;
        for(; l1 && l2; p = p->next){
            if(l1->val > l2->val){
                p->next = l2; l2 = l2->next;
            }
            else{
                p->next = l1; l1 = l1->next;
            }
        }
        p->next = l1 ? l1 : l2;
        return dummy.next;
    }

    ListNode* mergeKLists(vector<ListNode*>& lists) {
        if(lists.size() == 0) return nullptr;

        // multi pass
        deque<ListNode *> dq(lists.begin(), lists.end());
        while(dq.size() > 1){
            ListNode * first = dq.front(); dq.pop_front();
            ListNode * second = dq.front(); dq.pop_front();
            dq.push_back(mergeTwo(first,second));
        }

        return dq.front();
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Merge Sorted Array \S \ref{sec:merge-two-sorted-arrays}
\item Merge Two Sorted Lists，見 \S \ref{sec:merge-two-sorted-lists}
\myenddot


\section{Insertion Sort List} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:insertion-sort-list}


\subsubsection{描述}
Sort a linked list using insertion sort.


\subsubsection{分析}
無


\subsubsection{代碼}
\begin{Code}
// LeetCode, Insertion Sort List
// 時間複雜度O(n^2)，空間複雜度O(1)
class Solution {
public:
    ListNode *insertionSortList(ListNode *head) {
        ListNode dummy(INT_MIN);
        //dummy.next = head;

        for (ListNode *cur = head; cur != nullptr;) {
            auto pos = findInsertPos(&dummy, cur->val);
            ListNode *tmp = cur->next;
            cur->next = pos->next;
            pos->next = cur;
            cur = tmp;
        }
        return dummy.next;
    }

    ListNode* findInsertPos(ListNode *head, int x) {
        ListNode *pre = nullptr;
        for (ListNode *cur = head; cur != nullptr && cur->val <= x;
            pre = cur, cur = cur->next)
            ;
        return pre;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Sort List, 見 \S \ref{sec:sort-list}
\myenddot


\section{Sort List} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:sort-list}


\subsubsection{描述}
Sort a linked list in $O(n log n)$ time using constant space complexity.


\subsubsection{分析}
常數空間且$O(nlogn)$，單鏈表適合用歸併排序，雙向鏈表適合用快速排序。本題可以複用 "Merge Two Sorted Lists" 的代碼。


\subsubsection{代碼}
\begin{Code}
// LeetCode, Sort List
// 歸併排序，時間複雜度O(nlogn)，空間複雜度O(1)
class Solution {
public:
    ListNode *sortList(ListNode *head) {
        if (head == NULL || head->next == NULL)return head;

        // 快慢指針找到中間節點
        ListNode *fast = head, *slow = head;
        while (fast->next != NULL && fast->next->next != NULL) {
            fast = fast->next->next;
            slow = slow->next;
        }
        // 斷開
        fast = slow;
        slow = slow->next;
        fast->next = NULL;

        ListNode *l1 = sortList(head);  // 前半段排序
        ListNode *l2 = sortList(slow);  // 後半段排序
        return mergeTwoLists(l1, l2);
    }

    // Merge Two Sorted Lists
    ListNode *mergeTwoLists(ListNode *l1, ListNode *l2) {
        ListNode dummy(-1);
        for (ListNode* p = &dummy; l1 != nullptr || l2 != nullptr; p = p->next) {
            int val1 = l1 == nullptr ? INT_MAX : l1->val;
            int val2 = l2 == nullptr ? INT_MAX : l2->val;
            if (val1 <= val2) {
                p->next = l1;
                l1 = l1->next;
            } else {
                p->next = l2;
                l2 = l2->next;
            }
        }
        return dummy.next;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Insertion Sort List，見 \S \ref{sec:insertion-sort-list}
\myenddot


\section{Quick sort Array} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:quick-sort-array}


\subsubsection{描述}
Quick Sort and STD iterator


\subsubsection{分析}
無


\subsubsection{代碼1}
\begin{Code}
// Not from LeetCode
// 時間複雜度O(nlogn)，空間複雜度O(1)
class Solution {
public:
    template<class T>
    void QuickSort(T iter1, T iter2)
    {
        typename std::iterator_traits<T>::iterator_category t;
        __QuickSort(iter1, iter2, t);
    }
private:
    template<class T>
    void __QuickSort(T first, T last, std::bidirectional_iterator_tag)
    {
        if (first < last)
        {
            auto mid = Q_Partition(first, last);
            typename std::iterator_traits<T>::iterator_category t;
            __QuickSort(first, mid, t);
            __QuickSort(next(mid), last, t);
        }
    }
    template<class T>
    T Q_Partition(T first, T last)
    {
        T pivot = first;
        first = next(first);
        last = prev(last);
        while (first < last)
        {
            while (*first <= *pivot)
                first++;
            while (*last > *pivot)
                last--;

            if (first < last)
                swap(*first, *last);
        }
        swap(*last, *pivot);

        return last;
    }
\end{Code}


\subsubsection{相關題目}
No

\subsubsection{代碼2}
\begin{Code}
// Not from LeetCode
// 時間複雜度O(nlogn)，空間複雜度O(1)
class Solution {
public:
    void QuickSort(vector<int>& vec)
    {
        __QuickSort(vec, 0, vec.size());
    }
private:
    void __QuickSort(vector<int>& vec, int first, int last)
    {
        if (first < last)
        {
            int pivot = Q_Partition(vec, first, last);
            __QuickSort(vec, first, pivot);
            __QuickSort(vec, pivot + 1, last);
        }
    }
    int Q_Partition(vector<int>& vec, int first, int last)
    {
        int pivot = first;
        first++;
        last--;
        while (first < last)
        {
            while (vec[first] <= vec[pivot])
                first++;
            while (vec[last] > vec[pivot])
                last--;

            if (first < last)
                swap(vec[first], vec[last]);
        }
        swap(vec[pivot], vec[last]);

        return last;
    }
\end{Code}


\subsubsection{相關題目}
No
\newline

\section{Quick sort List} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:quick-sort-list}


\subsubsection{描述}
Quick Sort with singal linked list


\subsubsection{分析}
無


\subsubsection{代碼}
\begin{Code}
// Not from LeetCode
// 時間複雜度O(nlogn)，空間複雜度O(1)
class Solution {
public:
    void QuickSortList(ListNode *&head, ListNode *last = nullptr)
    {
        // return when not enough nodes
        if (head == nullptr || head->next == nullptr) return;
        if (head == last || head->next == last) return;

        ListNode *pivot = Q_PartitionList(head, last);
        QuickSortList(head, pivot);
        if (pivot != nullptr)
            QuickSortList(pivot->next, last);
    }
private:
    ListNode *Q_PartitionList(ListNode *&head, ListNode* last)
    {
        ListNode *pivot = head;
        ListNode left(-1), right(-1);
        right.next = last;
        ListNode *cur = head;
        while (cur != last)
        {
            ListNode *next = cur->next;
            if (pivot->val >= cur->val)
            {
                cur->next = left.next;
                left.next = cur;
            }
            else
            {
                cur->next = right.next;
                right.next = cur;
            }
            cur = next;
        }
        pivot->next = right.next;
        head = left.next;

        return pivot;
    }
\end{Code}


\subsubsection{相關題目}
No
\newline

\section{First Missing Positive} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:first-missing-positive}


\subsubsection{描述}
Given an unsorted integer array, find the first missing positive integer.

For example,
Given \fn{[1,2,0]} return \fn{3},
and \fn{[3,4,-1,1]} return \fn{2}.

Your algorithm should run in $O(n)$ time and uses constant space.


\subsubsection{分析}
本質上是桶排序(bucket sort)，每當\fn{A[i]!= i+1}的時候，將A[i]與A[A[i]-1]交換，直到無法交換為止，終止條件是 \fn{A[i]== A[A[i]-1]}。


\subsubsection{代碼}
\begin{Code}
// LeetCode, First Missing Positive
// 時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    int firstMissingPositive(vector<int>& nums) {
        bucket_sort(nums);

        for (int i = 0; i < nums.size(); ++i)
            if (nums[i] != (i + 1))
                return i + 1;
        return nums.size() + 1;
    }
private:
    static void bucket_sort(vector<int>& A) {
        const int n = A.size();
        for (int i = 0; i < n; i++) {
            while (A[i] != i + 1) {
                if (A[i] <= 0 || A[i] > n || A[i] == A[A[i] - 1])
                    break;
                swap(A[i], A[A[i] - 1]);
            }
        }
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Sort Colors, 見 \S \ref{sec:sort-colors}
\myenddot


\section{Sort Colors} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:sort-colors}


\subsubsection{描述}
Given an array with $n$ objects colored red, white or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white and blue.

Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.

Note:
You are not suppose to use the library's sort function for this problem.

\textbf{Follow up:}

A rather straight forward solution is a two-pass algorithm using counting sort.

First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's.

Could you come up with an one-pass algorithm using only constant space?


\subsubsection{分析}
由於0, 1, 2 非常緊湊，首先想到計數排序(counting sort)，但需要掃描兩遍，不符合題目要求。

由於只有三種顏色，可以設置兩個index，一個是red的index，一個是blue的index，兩邊往中間走。時間複雜度$O(n)$，空間複雜度$O(1)$。

第3種思路，利用快速排序裏 partition 的思想，第一次將數組按0分割，第二次按1分割，排序完畢，可以推廣到$n$種顏色，每種顏色有重複元素的情況。


\subsubsection{代碼1}
\begin{Code}
// LeetCode, Sort Colors
// Counting Sort
// 時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    void sortColors(vector<int>& A) {
        int counts[3] = { 0 }; // 記錄每個顏色出現的次數

        for (int i = 0; i < A.size(); i++)
            counts[A[i]]++;

        for (int i = 0, index = 0; i < 3; i++)
            for (int j = 0; j < counts[i]; j++)
                A[index++] = i;

    }
};
\end{Code}


\subsubsection{代碼2}
\begin{Code}
// LeetCode, Sort Colors
// 雙指針，時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    void sortColors(vector<int>& A) {
        // 一個是red的index，一個是blue的index，兩邊往中間走
        int red = 0, blue = A.size() - 1;

        for (int i = 0; i < blue + 1;) {
            if (A[i] == 0)
                swap(A[i++], A[red++]);
            else if (A[i] == 2)
                swap(A[i], A[blue--]);
            else
                i++;
        }
    }
};
\end{Code}


\subsubsection{代碼3}
\begin{Code}
// LeetCode, Sort Colors
// use partition()
// 時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    void sortColors(vector<int>& nums) {
        partition(partition(nums.begin(), nums.end(), bind1st(equal_to<int>(), 0)),
                nums.end(), bind1st(equal_to<int>(), 1));
    }
};
\end{Code}


\subsubsection{代碼4}
\begin{Code}
// LeetCode, Sort Colors
// 重新實現 partition()
// 時間複雜度O(n)，空間複雜度O(1)
class Solution {
public:
    void sortColors(vector<int>& nums) {
        partition(partition(nums.begin(), nums.end(), bind1st(equal_to<int>(), 0)),
                 nums.end(), bind1st(equal_to<int>(), 1));
    }
private:
    template<typename ForwardIterator, typename UnaryPredicate>
    ForwardIterator partition(ForwardIterator first, ForwardIterator last,
            UnaryPredicate pred) {
        auto pos = first;

        for (; first != last; ++first)
            if (pred(*first))
                swap(*first, *pos++);

        return pos;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item First Missing Positive, 見 \S \ref{sec:first-missing-positive}
\myenddot


\section{Heap Sort} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:heap-sort}


\subsubsection{描述}
Remake std heap_sort heap_make heap_pop heap_push, also using iterator type


\subsubsection{分析}
Learn from STL源碼剖析 侯捷


\subsubsection{代碼}
\begin{Code}
// LeetCode, Heap Sort
// Heap Sort
// 時間複雜度O(nlogn)，空間複雜度O(1)
class Solution {
public:
    template<class T>
        void PushHeap(T first, T last)
    {
        // Assume the value is pushed to the vector
        typename std::iterator_traits<T>::iterator_category t;
        __PushHeapAux(first, last, t);
    }
    template<class T>
        void PopHeap(T first, T last)
    {
        // will move the value to the last element
        typename std::iterator_traits<T>::iterator_category t;
        __PopHeapAux(first, last, t);
    }
    template <class RandomAccessIterator>
        void SortHeap (RandomAccessIterator first, RandomAccessIterator last)
    {
        while (last - first > 1)
            PopHeap(first, last--);
    }
    template <class T>
        inline void MakeHeap (T first, T last)
    {
        typename std::iterator_traits<T>::iterator_category t;
        __MakeHeap(first, last, t);
    }
private:
    template <class RandomAccessIterator, class Distance, class T>
    void __PushHeap (RandomAccessIterator first
                    , Distance holeIndex, Distance topIndex, T value)
    {
        // percolate up
        Distance parent = (holeIndex - 1) / 2; // find father node
        while (holeIndex > topIndex && *next(first, parent) < value)
        {
            *(first + holeIndex) = *(first + parent);
            holeIndex = parent;
            parent = (holeIndex - 1) / 2;
        }
        *(first + holeIndex) = value;
    }
    template<class T>
        void __PushHeapAux(T first, T last, std::random_access_iterator_tag)
    {
        __PushHeap(first, distance(first, prev(last)), distance(first, first), *prev(last));
    }
    template <class RandomAccessIterator, class Distance, class T>
    void __AdjustHeap (RandomAccessIterator first
                      , Distance holeIndex, Distance len, T value)
    {
        // percolate down
        Distance topIndex = holeIndex;
        Distance secondChild = 2 * holeIndex + 2;
        while (secondChild < len)
        {
            if (*(first + secondChild) < *(first + (secondChild - 1)))
                secondChild--;
            *(first + holeIndex) = *(first + secondChild);
            holeIndex = secondChild;
            secondChild = 2 * (secondChild + 1);
        }
        if (secondChild == len) // only left child case
        {
            *(first + holeIndex) = *(first + (secondChild - 1));
            holeIndex = secondChild - 1;
        }
        __PushHeap (first, holeIndex, topIndex, value);
    }
    template <class RandomAccessIterator, class T>
    void __PopHeap (RandomAccessIterator first
                   , RandomAccessIterator last, RandomAccessIterator result, T value)
    {
        *result = *first;
        __AdjustHeap(first, distance(first, first), distance(first, last), value);
    }
    template<class T>
        void __PopHeapAux(T first, T last, std::random_access_iterator_tag)
    {
        __PopHeap(first, prev(last), prev(last), *prev(last));
    }
    template <class T>
        void __MakeHeap (T first, T last, std::random_access_iterator_tag)
    {
        if (last - first < 2) return;
        auto len = distance(first, last);
        auto holeIndex = (len - 2) / 2;

        while (true)
        {
            __AdjustHeap(first, holeIndex, len, *next(first, holeIndex));
            if (holeIndex == 0) return;
            holeIndex--;
        }
    }
};

void TryHeap()
{
    using namespace std;
    vector<int> ivec = {0,1,2,3,4,8,9,3,5};

    RM::MakeHeap(ivec.begin(), ivec.end());
    for (size_t i = 0; i < ivec.size(); ++i)
        cout << ivec[i] << " ";
    cout << endl;

    ivec.push_back(7);
    cout << distance(ivec.begin(), ivec.end())
         << " " << distance(ivec.begin(), prev(ivec.end())) << endl;
    RM::PushHeap(ivec.begin(), ivec.end());
    for (size_t i = 0; i < ivec.size(); ++i)
        cout << ivec[i] << " ";
    cout << endl;

    RM::PopHeap(ivec.begin(), ivec.end());
    cout << ivec.back() << endl;
    ivec.pop_back();

    for (size_t i = 0; i < ivec.size(); ++i)
        cout << ivec[i] << " ";
    cout << endl;

    RM::SortHeap(ivec.begin(), ivec.end());
    for (size_t i = 0; i < ivec.size(); ++i)
        cout << ivec[i] << " ";
    cout << endl;
}
\end{Code}

\subsubsection{相關題目}
No
