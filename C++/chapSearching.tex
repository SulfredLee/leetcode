\chapter{查找}


\section{Search for a Range} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:search-for-a-range}


\subsubsection{描述}
Given a sorted array of integers, find the starting and ending position of a given target value.

Your algorithm's runtime complexity must be in the order of $O(\log n)$.

If the target is not found in the array, return \code{\[-1, -1\]}.

For example,
Given \code{\[5, 7, 7, 8, 8, 10\]} and target value 8,
return \code{\[3, 4\]}.


\subsubsection{分析}
已經排好了序，用二分查找。


\subsubsection{使用STL}
\begin{Code}
// LeetCode, Search for a Range
// 偷懶的做法，使用STL
// 時間複雜度O(logn)，空間複雜度O(1)
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        const int l = distance(nums.begin(), lower_bound(nums.begin(), nums.end(), target));
        const int u =
              distance(nums.begin(), prev(upper_bound(nums.begin(), nums.end(), target)));
        if (nums[l] != target) // not found
            return vector<int> { -1, -1 };
        else
            return vector<int> { l, u };
    }
};
\end{Code}


\subsubsection{重新實現 lower_bound 和 upper_bound}
\begin{Code}
// LeetCode, Search for a Range
// 重新實現 lower_bound 和 upper_bound
// 時間複雜度O(logn)，空間複雜度O(1)
class Solution {
public:
    vector<int> searchRange (vector<int>& nums, int target) {
        auto lower = lower_bound(nums.begin(), nums.end(), target);
        auto uppper = upper_bound(lower, nums.end(), target);

        if (lower == nums.end() || *lower != target)
            return vector<int> { -1, -1 };
        else
            return vector<int> {distance(nums.begin(), lower),
                                distance(nums.begin(), prev(uppper))};
    }

    template<typename ForwardIterator, typename T>
    ForwardIterator lower_bound (ForwardIterator first,
            ForwardIterator last, T value) {
        while (first != last) {
            auto mid = next(first, distance(first, last) / 2);

            if (value > *mid)   first = ++mid;
            else                last = mid;
        }

        return first;
    }

    template<typename ForwardIterator, typename T>
    ForwardIterator upper_bound (ForwardIterator first,
            ForwardIterator last, T value) {
        while (first != last) {
            auto mid = next(first, distance (first, last) / 2);

            if (value >= *mid)   first = ++mid;  // 與 lower_bound 僅此不同
            else                 last = mid;
        }

        return first;
    }
};
\end{Code}

\subsubsection{相關題目}
\begindot
\item Search Insert Position, 見 \S \ref{sec:search-insert-position}
\myenddot


\section{Search Insert Position} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:search-insert-position}


\subsubsection{描述}
Given a sorted array and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.

You may assume no duplicates in the array.

Here are few examples.
\begin{Code}
[1,3,5,6], 5 → 2
[1,3,5,6], 2 → 1
[1,3,5,6], 7 → 4
[1,3,5,6], 0 → 0
\end{Code}


\subsubsection{分析}
即\fn{std::lower_bound()}。


\subsubsection{代碼}
\begin{Code}
// LeetCode, Search Insert Position
// 重新實現 lower_bound
// 時間複雜度O(logn)，空間複雜度O(1)
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        return distance(nums.begin(), lower_bound(nums.begin(), nums.end(), target));
    }

    template<typename ForwardIterator, typename T>
    ForwardIterator lower_bound (ForwardIterator first,
            ForwardIterator last, T value) {
        while (first != last) {
            auto mid = next(first, distance(first, last) / 2);

            if (value > *mid)   first = ++mid;
            else                last = mid;
        }

        return first;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item Search for a Range, 見 \S \ref{sec:search-for-a-range}
\myenddot


\section{Search a 2D Matrix} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:search-a-2d-matrix}


\subsubsection{描述}
Write an efficient algorithm that searches for a value in an $m \times n$ matrix. This matrix has the following properties:
\begindot
\item Integers in each row are sorted from left to right.
\item The first integer of each row is greater than the last integer of the previous row.
\myenddot

For example, Consider the following matrix:
\begin{Code}
[
  [1,   3,  5,  7],
  [10, 11, 16, 20],
  [23, 30, 34, 50]
]
\end{Code}
Given \fn{target = 3}, return true.


\subsubsection{分析}
二分查找。


\subsubsection{代碼}
\begin{Code}
// LeetCode, Search a 2D Matrix
// 時間複雜度O(logn)，空間複雜度O(1)
class Solution {
public:
    bool searchMatrix(const vector<vector<int>>& matrix, int target) {
        if (matrix.empty()) return false;
        const size_t  m = matrix.size();
        const size_t n = matrix.front().size();

        int first = 0;
        int last = m * n;

        while (first < last) {
            int mid = first + (last - first) / 2;
            int value = matrix[mid / n][mid % n];

            if (value == target)
                return true;
            else if (value < target)
                first = mid + 1;
            else
                last = mid;
        }

        return false;
    }
};
\end{Code}


\subsubsection{相關題目}
\begindot
\item 無
\myenddot

\section{Search a 2D Matrix II} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:search-a-2d-matrix-ii}


\subsubsection{描述}
Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
\begindot
\item Integers in each row are sorted in ascending from left to right.
\item Integers in each column are sorted in ascending from top to bottom.
\myenddot

For example, Consider the following matrix:
\begin{Code}
[
  [1,   4,  7, 11, 15],
  [2,   5,  8, 12, 19],
  [3,   6,  9, 16, 22],
  [10, 13, 14, 17, 24],
  [18, 21, 23, 26, 30]
]
\end{Code}
Given \fn{target = 3}, return true.


\subsubsection{分析}
二分查找。


\subsubsection{代碼}
\begin{Code}
// 時間複雜度O(m+n)，空間複雜度O(1)
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int row = matrix.size() - 1;
        if (row < 0) return false;
        int col = 0;

        while (row >= 0 && col < matrix[0].size())
        {
            if (matrix[row][col] > target)
                row--;
            else if (matrix[row][col] < target)
                col++;
            else
                return true;
        }

        return false;
    }
};
\end{Code}

\subsubsection{分治}
\begin{Code}
// 時間複雜度O(nlogn)，空間複雜度O(logn)
class Solution {
public:
    bool searchMatrix(vector<vector<int>>& matrix, int target) {
        int M = matrix.size();
        if (M == 0) return false;
        int N = matrix[0].size();
        if (N == 0) return false;

        return searchRec(matrix, target, 0, 0, N-1, M-1);
    }
private:
    bool searchRec(vector<vector<int>>& matrix, const int& target
                   , int left, int up, int right, int down)
    {
        // 若果 matrix 已經不成形
        if (left > right || up > down)
            return false;
        else if (target < matrix[up][left] || target > matrix[down][right])
            return false; //  target 不在 matrix 之中

        int mid = left + (right - left) / 2; // 使用 index 中
        int row = up;
        while (row <= down && matrix[row][mid] <= target)
        {
            if (matrix[row][mid] == target)
                return true;
            row++;
        }
        return searchRec(matrix, target, left, row, mid-1, down)
            || searchRec(matrix, target, mid+1, up, right, row-1);
    }
};
\end{Code}

\subsubsection{相關題目}
\begindot
\item 無
\myenddot

\section{Find Peak Element} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:find-peadk-element}


\subsubsection{描述}
A peak element is an element that is greater than its neighbors.

Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.

The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.

You may imagine that nums[-1] = nums[n] = -∞.

Example 1:
\begin{Code}
Input: nums = [1,2,3,1]
Output: 2
Explanation: 3 is a peak element and your function should return the index number 2.
\end{Code}

Example 2:
\begin{Code}
Input: nums = [1,2,1,3,5,6,4]
Output: 1 or 5 
Explanation: Your function can return either index number 1 where the peak element is 2, 
             or index number 5 where the peak element is 6.
\end{Code}

\subsubsection{分析}
二分查找。


\subsection{迭代}
\begin{Code}
// 時間複雜度O(logn)，空間複雜度O(logn)
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        return findPeak(nums, 0, nums.size()-1);
    }
private:
    int findPeak(const vector<int>& nums, int left, int right)
    {
        while (left <= right)
        {
            int mid = left + (right - left) / 2;

            if (left == right)
                return left;
            if (nums[mid] > nums[mid + 1])
                right = mid;
            else
                left = ++mid;
        }
        return left;
    }
};
\end{Code}

\subsection{遞歸}
\begin{Code}
// 時間複雜度O(logn)，空間複雜度O(logn)
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        return findPeak(nums, 0, nums.size()-1);
    }
private:
    int findPeak(const vector<int>& nums, int left, int right)
    {
        if (left == right)
            return left;
        int mid = left + (right - left) / 2;
        if (nums[mid] > nums[mid+1])
            return findPeak(nums, left, mid);
        else
            return findPeak(nums, ++mid, right);
    }
};
\end{Code}

\subsubsection{相關題目}
\begindot
\item 無
\myenddot

\section{Find Minimum in Rotated Sorted Array} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:find-minium-in-rotated-sorted-array}


\subsubsection{描述}
Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.

(i.e.,  [0,1,2,4,5,6,7] might become  [4,5,6,7,0,1,2]).

Find the minimum element.

You may assume no duplicate exists in the array.

Example 1:
\begin{Code}
Input: [3,4,5,1,2] 
Output: 1
\end{Code}

Example 2:
\begin{Code}
Input: [4,5,6,7,0,1,2]
Output: 0
\end{Code}

\subsubsection{分析}
二分查找。


\subsection{迭代}
\begin{Code}
// 時間複雜度O(logn)，空間複雜度O(logn)
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size();
        int minVal = INT_MAX;

        while (left < right) {
            int mid = left + (right - left) / 2;

            int nextIndex = 0;
            if (nums[left] < nums[mid]) {
                nextIndex = left;
                left = ++mid;
            }
            else if (nums[mid] < nums[right-1]) {
                nextIndex = mid;
                right = mid;
            }
            else if (nums[left] >= nums[mid]) {
                nextIndex = mid;
                left = ++mid;
            }
            else if (nums[mid] >= nums[right - 1]) {
                nextIndex = right -1;
                right = mid;
            }

            if (minVal > nums[nextIndex])
                minVal = nums[nextIndex];
        }

        return minVal;
    }
};
\end{Code}


\subsection{遞歸}
\begin{Code}
// 時間複雜度O(logn)，空間複雜度O(logn)
class Solution {
public:
    int findMin(vector<int>& nums) {
        int left = 0;
        int right = nums.size();
        int minVal = INT_MAX;
        return DFS(nums, left, right, minVal);
    }
private:
    int DFS(const vector<int>& nums, int left, int right, int& minVal) {
        if (left < right) {
            int mid = left + (right - left) / 2;

            int nextIndex = 0;
            if (nums[left] < nums[mid]) {
                nextIndex = left;
                left = ++mid;
            }
            else if (nums[mid] < nums[right-1]) {
                nextIndex = mid;
                right = mid;
            }
            else if (nums[left] >= nums[mid]) {
                nextIndex = mid;
                left = ++mid;
            }
            else if (nums[mid] >= nums[right - 1]) {
                nextIndex = right -1;
                right = mid;
            }

            if (minVal > nums[nextIndex])
                minVal = nums[nextIndex];

            return DFS(nums, left, right, minVal);
        }
        return minVal;
    }
};
\end{Code}

\section{Find Minimum in Rotated Sorted Array} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{sec:find-minium-in-rotated-sorted-array}


\subsubsection{描述}
Given a sorted array arr, two integers k and x, find the k closest elements to x in the array. The result should also be sorted in ascending order. If there is a tie, the smaller elements are always preferred.

Example 1:
\begin{Code}
Input: arr = [1,2,3,4,5], k = 4, x = 3
Output: [1,2,3,4]
\end{Code}

Example 2:
\begin{Code}
Input: arr = [1,2,3,4,5], k = 4, x = -1
Output: [1,2,3,4]
\end{Code}

\subsubsection{分析}
二分查找。


\subsection{迭代}
\begin{Code}
// 時間複雜度O(logn)，空間複雜度O(logn)
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        if ((int)arr.size() <= k) return arr;

        auto pos = ClosestSearch(arr.begin(), arr.end(), x);
        // 使用兩個指針，往左右走開，若差相同，先取左（細），後取右（大）
        if (pos == arr.end()) {
            return vector<int>(prev(arr.end(), k), arr.end());
        }
        else {
            auto left = pos;
            auto right = next(pos);
            cout << *pos << endl;
            --k;

            while (k && left != arr.begin() && right != arr.end()) {
                // 若差相同，先取左（細），後取右（大）
                if (abs(*prev(left) - x) <= abs(*right - x))
                    left = prev(left);
                else
                    right = next(right);
                --k;
            }
            if (k) {
                if (left == arr.begin()) {
                    while (k--) right = next(right);
                }
                else {
                    while (k--) left = prev(left);
                }
            }

            return vector<int>(left, right);
        }
    }
private:
    template <class RandIT, class T>
        RandIT ClosestSearch(RandIT left, RandIT right, const T& target) {
        RandIT first = left;
        RandIT last = right;
        while (left != right) {
            auto mid = next(left, distance(left, right) / 2);

            if (*mid == target) return mid;
            if (*mid < target)
                left = next(mid);
            else
                right = mid;
        }

        if (left == first) return left;
        if (left != last) {
            if (abs(*prev(left) - target) <= abs(*left - target))
                return prev(left);
            else
                return left;
        }

        return left;
    }
};
\end{Code}
